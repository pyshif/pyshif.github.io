<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSH 客戶端基本操作／多主機、Git 儲存庫管理</title>
    <link href="/2023/02/27/SSH-%E5%AE%A2%E6%88%B6%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8F%E5%A4%9A%E4%B8%BB%E6%A9%9F%E3%80%81Git-%E5%84%B2%E5%AD%98%E5%BA%AB%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/27/SSH-%E5%AE%A2%E6%88%B6%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8F%E5%A4%9A%E4%B8%BB%E6%A9%9F%E3%80%81Git-%E5%84%B2%E5%AD%98%E5%BA%AB%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整理 SSH 連線操作方式，執行環境為 Mac 13.0</p><h2 id="SSH-是什麼？"><a href="#SSH-是什麼？" class="headerlink" title="SSH 是什麼？"></a>SSH 是什麼？</h2><p>SSH (Secure Shell) 是一種加密的網路協議，可以用來遠程連接到另一台計算機並進行管理和傳輸文件。另外，Git 遠端庫的連線也是一個很常見的使用情境。</p><ul><li>OpenSSH 是 SSH 協議的的實作（就像 JavaScript 之於 ECMAScript）</li></ul><h2 id="要如何生成-SSH-Key？"><a href="#要如何生成-SSH-Key？" class="headerlink" title="要如何生成 SSH Key？"></a>要如何生成 SSH Key？</h2><p>使用 <code>ssh-keygen</code> 指令，即可生成 SSH 金鑰對（私鑰＋公鑰），預設儲存在 <code>~/.ssh</code> ，也可透過 <code>-f</code> 指定路徑及檔案名稱。</p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ssh-keygen</span> <span class="hljs-string">-t rsa -b 4096 -C &quot;&lt;your-email&gt;@mail.com&quot; -f &quot;.ssh/id_rsa.[label]&quot; -P &quot;&quot;</span><br></code></pre></td></tr></table></figure><p><code>-C</code> 是用來填入註解，方便識別不同金鑰的用途。關於更詳細的規格，使用 <code>man ssh-keygen</code> 查看</p><h2 id="要如何使用-SSH-進行連線？"><a href="#要如何使用-SSH-進行連線？" class="headerlink" title="要如何使用 SSH 進行連線？"></a>要如何使用 SSH 進行連線？</h2><p>在我們有了『公、私鑰』後，在進行連線前，我們需要將『公鑰』交給我們通信的對象（計算機）。</p><ul><li><p>在『管理主機』的情境下，我們要將『公鑰』寫入到主機 <code>~/.ssh/authorized_keys</code> 檔案中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 將『公鑰』傳到『主機』上</span><br><span class="hljs-attr">scp</span> <span class="hljs-string">-i &lt;private-key&gt; &lt;public-key&gt; &lt;user&gt;@&lt;ip&gt;:&lt;path&gt;</span><br><span class="hljs-comment"># 進入『主機』</span><br><span class="hljs-attr">ssh</span> <span class="hljs-string">-i &lt;private-key&gt; &lt;user&gt;@&lt;ip&gt;</span><br><span class="hljs-comment"># 將『公鑰』寫入授權檔</span><br><span class="hljs-attr">cat</span> <span class="hljs-string">~/.ssh/id_rsa.public-key.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure><p>小心指令是 <code>&gt;&gt;</code> 而非 <code>&gt;</code>（單箭號會覆蓋掉原有內容）。此處的 <code>&lt;private-key&gt;</code> 通常是由主機商提供預設的私鑰</p></li><li><p>在 『Git 使用情境』下，則是將『公鑰』複製到 GitHub、GitLab 指定的 SSH Key 儲存位置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 將『公鑰』寫入『剪貼簿』</span><br><span class="hljs-attr">pbcopy</span> <span class="hljs-string">&lt; ~/.ssh/id_rsa.public-key.pub</span><br></code></pre></td></tr></table></figure><p>在『非對稱加密連線』中，『公鑰』是用來給通信對象加密他們要傳輸的訊息；而『私鑰』則是自己保留，用來在收到加密訊息後進行解密用。</p></li></ul><p>在『公鑰』交付給我們的通信對象後，即可進行連線：</p><ul><li><p>在『管理主機』的情境下，我們即可使用 <code>ssh</code> 指令進行連線：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 格式</span><br><span class="hljs-attr">ssh</span> <span class="hljs-string">-i &lt;your-private-key&gt; &lt;user&gt;@&lt;ip&gt;</span><br><span class="hljs-comment"># 範例</span><br><span class="hljs-attr">ssh</span> <span class="hljs-string">-i ~/.ssh/id_rsa.aws centos@48.236.219.87</span><br></code></pre></td></tr></table></figure></li><li><p>在『Git 使用情境下』，我們則需要將『私鑰』加入 SSH Agent 中：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 啟用 ssh agent 服務</span><br><span class="hljs-attr">eval</span> <span class="hljs-string">$(ssh-agent -s)</span><br><span class="hljs-comment"># 將私鑰加入 agent 中</span><br><span class="hljs-attr">ssh-add</span> <span class="hljs-string">~/.ssh/id_rsa.aws</span><br><span class="hljs-comment"># 確認私鑰已加入</span><br><span class="hljs-attr">ssh-add</span> <span class="hljs-string">-l</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="如何對『多個』雲端主機、或-Git-儲存庫進行『SSH-設定和管理』？"><a href="#如何對『多個』雲端主機、或-Git-儲存庫進行『SSH-設定和管理』？" class="headerlink" title="如何對『多個』雲端主機、或 Git 儲存庫進行『SSH 設定和管理』？"></a>如何對『多個』雲端主機、或 Git 儲存庫進行『SSH 設定和管理』？</h2><p>當我們要『管理多主機』或是『多 Git 遠端庫』時，會需要『編寫 SSH 設定檔』，以此來：</p><ul><li>『簡化連線指令』</li><li>『區分同域名下，不同 SSH 連線』</li></ul><blockquote><p>『同域名』不同『金鑰』，SSH 無法進行區分</p></blockquote><p>在設定檔中，SSH 會由上而下檢查 <code>Host</code> 名稱規則，符合則套用設定：</p><ul><li><p>在『主機管理』的情境下，編寫完設定檔後，直接可以使用 <code>Host</code> 名稱進行連線：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># /etc/ssh/ssh_config 系統層級的 SSH 設定檔</span><br><br><span class="hljs-attr">Host</span> <span class="hljs-string">aws                                # 別名</span><br>    <span class="hljs-attr">HostName</span> <span class="hljs-string">48.236.219.87              # 實際連線位置</span><br>    <span class="hljs-attr">User</span> <span class="hljs-string">centos                         # 主機使用者</span><br>    <span class="hljs-attr">IdentityFile</span> <span class="hljs-string">~/.ssh/id_rsa.aws      # 私鑰檔案</span><br><br><span class="hljs-attr">Host</span> <span class="hljs-string">*</span><br>    <span class="hljs-attr">Prot</span> <span class="hljs-string">22</span><br><br><span class="hljs-attr">Host</span> <span class="hljs-string">*</span><br>    <span class="hljs-attr">SendEnv</span> <span class="hljs-string">LANG LC_*</span><br></code></pre></td></tr></table></figure><p>如果你想將設定檔內容，寫在使用者層級也可以 <code>~/.ssh/config</code></p><p>當設定檔完成後，連線的指令就會簡化如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 連線 至 48.236.219.87</span><br><span class="hljs-attr">ssh</span> <span class="hljs-string">aws </span><br></code></pre></td></tr></table></figure></li><li><p>在『Git 使用情境』下，我們需要進行比較繁瑣的設定：</p><p>編寫 SSH 設定檔，建立 <code>Host</code> 別名</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># /etc/ssh/ssh_config 系統層級的 SSH 設定檔</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 私人 GitHub 帳號</span><br><span class="hljs-attr">Host</span> <span class="hljs-string">github.com                         # 別名</span><br>    <span class="hljs-attr">HostName</span> <span class="hljs-string">github.com                 # 實際連線位置</span><br>    <span class="hljs-attr">AddKeysToAgent</span> <span class="hljs-string">yes                  # 自動加入 agent</span><br>    <span class="hljs-attr">IgnoreUnknown</span> <span class="hljs-string">UseKeychain           # 忽略 KeyChain 錯誤訊息</span><br>    <span class="hljs-attr">IdentityFile</span> <span class="hljs-string">~/.ssh/id_rsa.default  # 私鑰檔案</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 工作用 GitHub 帳號</span><br><span class="hljs-attr">Host</span> <span class="hljs-string">work.github.com</span><br>    <span class="hljs-attr">HostName</span> <span class="hljs-string">github.com</span><br>    <span class="hljs-attr">AddKeysToAgent</span> <span class="hljs-string">yes</span><br>    <span class="hljs-attr">IgnoreUnknown</span> <span class="hljs-string">UseKeychain</span><br>    <span class="hljs-attr">IdentityFile</span> <span class="hljs-string">~/.ssh/id_rsa.work</span><br><br><span class="hljs-attr">Host</span> <span class="hljs-string">*</span><br>    <span class="hljs-attr">Port</span> <span class="hljs-string">22</span><br><br><span class="hljs-attr">Host</span> <span class="hljs-string">*</span><br>    <span class="hljs-attr">SendEnv</span> <span class="hljs-string">LANG LC_*</span><br></code></pre></td></tr></table></figure><p>確認『私鑰』加入 SSH Agent 中（ssh-agent 服務要先啟用）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 加入 私人 GitHub 帳號 私鑰</span><br><span class="hljs-attr">ssh-add</span> <span class="hljs-string">~/.ssh/id_rsa.default</span><br><span class="hljs-comment"># 加入 工作用 GitHub 帳號 私鑰</span><br><span class="hljs-attr">ssh-add</span> <span class="hljs-string">~/.ssh/id_rsa.work</span><br></code></pre></td></tr></table></figure><p>更改 SSH URL 中 domain 的位置，使其匹配設定檔中的 <code>Host</code>（預設帳號無需更動）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># SSH URL 結構 git@&lt;domain&gt;:&lt;user&gt;/&lt;repo&gt;.git`</span><br><span class="hljs-attr">git</span> <span class="hljs-string">remote set-url origin git@work.github.com:user/repo.git</span><br></code></pre></td></tr></table></figure><p>更改 Git 使用者資訊（依照專案需求，調整 Git 本地／使用者層級設定檔）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># /&lt;project-root&gt;/.git/config</span><br><br><span class="hljs-attr">[user]</span><br>    <span class="hljs-attr">email</span>=<span class="hljs-string">user@mail.com </span><br>    <span class="hljs-attr">name</span>=<span class="hljs-string">user</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># or</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ~/.gitconfig</span><br><br><span class="hljs-attr">[user]</span><br>    <span class="hljs-attr">email</span>=<span class="hljs-string">user@mail.com</span><br>    <span class="hljs-attr">name</span>=<span class="hljs-string">user</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="遺珠"><a href="#遺珠" class="headerlink" title="遺珠"></a>遺珠</h2><ul><li>雖然 <code>ssh_config</code> 中有寫上 <code>AddKeysToAgent</code>，但筆者在實測過程中發現，『同域名』的情況下仍須『手動加入』或『寫入終端設定檔』。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>想知道『入門觀念』，可以參考<a href="https://codecharms.me/posts/security-ssh">你該知道所有關於 SSH 的那些事</a></p></li><li><p>想知道『完整介紹』，可以參考<a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys#generating-and-working-with-ssh-keys">SSH Essentials: Working with SSH Servers, Clients, and Keys</a></p></li><li><p>想知道『Git 多帳號管理』，可以參考<a href="https://gist.github.com/alejandro-martin/aabe88cf15871121e076f66b65306610">Configure multiple SSH Keys for Git | GitHub Gist</a></p></li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><p><a href="https://gist.github.com/alejandro-martin/aabe88cf15871121e076f66b65306610">Configure multiple SSH Keys for Git | GitHub Gist</a></p></li><li><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">Generating a new SSH key and adding it to the ssh-agent | GitHub Docs</a></p></li><li><p><a href="https://codecharms.me/posts/security-ssh">你該知道所有關於 SSH 的那些事</a></p></li><li><p><a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys#generating-and-working-with-ssh-keys">SSH Essentials: Working with SSH Servers, Clients, and Keys</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git, ssh, ssh-keygen, ssh-add, ssh-agent, ssh_config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 Vue 3 ref() 和 reactive()</title>
    <link href="/2023/01/26/%E7%90%86%E8%A7%A3-Vue-3-ref-%E5%92%8C-reactive/"/>
    <url>/2023/01/26/%E7%90%86%E8%A7%A3-Vue-3-ref-%E5%92%8C-reactive/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在閱讀 Vue 3 文件中的 <a href="https://vuejs.org/guide/essentials/reactivity-fundamentals.html">Reactive Fundamentals (Composition API)</a> 時，對於文件敘述 <code>ref()</code> 和 <code>reactive()</code> 的不同有些疑惑，因此進行了一些實驗（環境：vue 3.2.45）。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>從 Vue 3 的文件中（<a href="https://vuejs.org/guide/essentials/reactivity-fundamentals.html">Reactive Fundamentals (Compisition API)</a>）我們知道 <code>reactive()</code> 只能用於創建『對象類型的資料 (objects, arrays, and collection types such as Map and Set)』而 <code>ref()</code> 可以接受『任何類型』。</p><p>在看過 Vue 3 <a href="https://github.com/vuejs/core/blob/main/packages/reactivity/src/ref.ts">ref() 源代碼</a> 中，我們得到：</p><ul><li>如果是原始型態，單純將值存儲於物件的 <code>.value</code> 屬性中。</li><li>如果是狀態是對象型態『<code>ref()</code> 底層仍是使用 <code>reactive()</code> 來實現狀態的存儲』。</li></ul><p>基於源代碼內的實現，我們可以看出來 <code>ref()</code> 其實就是替我們創建了一個『對象』，並將『狀態』存儲於該對象的 <code>.value</code> 屬性當中，所以相比 <code>reactive()</code> 才可以存儲任何類型的資料，直接進行操作而不和響應式系統斷開（因為我們操作的始終是 <code>.value</code> 中的資料）。</p><p>上述這些統整一下，我們可以得到幾個結論：</p><ul><li>對於 Vue 3 的響應式系統而言，狀態必須以『對象型態』進行存儲（不論是使用 <code>reactive()</code> 自行創建，抑或是使用 <code>ref()</code> 替我們在底層創建）</li></ul><details><summary>這是由於『JavaScript 中沒有作用於所有值類型的引用機制』，只有『對象 object types』是以址參器（reference）進行存儲</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 對象型態是以址參器方式存儲 obj1 和 obj2 是同塊記憶體位址，更改 obj1 同時影響 obj2</span><br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = obj1;<br><br>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;B&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;B&#x27;</span><br><br><span class="hljs-comment">// 解構賦值（模擬狀態與響應式系統斷開）</span><br><span class="hljs-keyword">let</span> &#123; name &#125; = obj1;<br>name = <span class="hljs-string">&#x27;C&#x27;</span>; <span class="hljs-comment">// 此時的 name 已經不是 obj1.name</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &#x27;C&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;B&#x27;</span><br><br><span class="hljs-comment">// 原始型態是以值的方式存儲，而非址參器</span><br><span class="hljs-keyword">let</span> number1 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> number2 = number1;<br><br>number1 = <span class="hljs-number">11</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number1); <span class="hljs-comment">// 11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number2); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></details><blockquote><p>這是由於『JavaScript 中沒有作用於所有值類型的引用機制』，只有『對象 object types』是以址參器（reference）的方式存儲。</p></blockquote><ul><li><p>不論你是使用 <code>ref()</code> 還是 <code>reactive()</code> 創建狀態，在使用時都要確定操作的對象都是『狀態對象』本身（就是 <code>ref()</code> 或 <code>reactive()</code> 返回的對象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>）。因為透過該對象進行操作，Vue 的響應式系統才能捕捉到狀態的變化。</p></li><li><p>使用 <code>ref()</code> 還是 <code>reactive()</code> 取決於開發者自己本身的考量</p></li></ul><h2 id="ref-源代碼"><a href="#ref-源代碼" class="headerlink" title="ref() 源代碼"></a><a href="https://github.com/vuejs/core/blob/main/packages/reactivity/src/ref.ts">ref() 源代碼</a></h2><ul><li>ref(), createRef(), RefImpl class</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// core/packages/reactivity/src/ref.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">value?: <span class="hljs-built_in">unknown</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value, <span class="hljs-literal">false</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params">rawValue: <span class="hljs-built_in">unknown</span>, shallow: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(rawValue)) &#123;<br>    <span class="hljs-keyword">return</span> rawValue<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>(rawValue, shallow)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span>&lt;T&gt; &#123;<br>  <span class="hljs-comment">// ... 省略</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: T, <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> __v_isShallow: <span class="hljs-built_in">boolean</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span> = __v_isShallow ? value : <span class="hljs-title function_">toRaw</span>(value)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = __v_isShallow ? value : <span class="hljs-title function_">toReactive</span>(value)<br>  &#125;<br><br>  <span class="hljs-comment">// ... 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>toReactive()</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// core/packages/reactivity/src/reactive.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> toReactive = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>&gt;(<span class="hljs-attr">value</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span><br>  <span class="hljs-title function_">isObject</span>(value) ? <span class="hljs-title function_">reactive</span>(value) : value<br></code></pre></td></tr></table></figure><p>從上方 <code>ref()</code> 源代碼，我們可以看到，當我創建狀態時，會發生這些事：</p><ul><li>內部會呼叫 <code>createRef()</code> 這個函式</li><li><code>createRef()</code> 返回一個 <code>RefImpl</code> 類的實例</li><li><code>RefImpl</code> 建構式中由於傳入的 <code>__v_isShallow</code> 為 <code>false</code>，因此會呼叫 <code>toReactive()</code> 函式並將返回值其存儲在 <code>this.value</code> 中</li></ul><p>我們可以看到 <code>toReactive</code> 函式，會判斷傳入的狀態是否為『對象型態』，如果是就用 <code>reactive</code> 來創建（Vue 3 文件說的 reactive 化），如果否就單純回傳值。</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://medium.com/@bsalwiczek/ref-vs-reactive-in-vue-3-whats-the-right-choice-7c6f7265ce39">Ref() vs Reactive() in Vue 3 — what’s the right choice? | Bartosz Salwiczek</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue, ref, reactive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>關於 JS 模組化：CMJ, AMD, CMD, UMD, ESM, IIFE</title>
    <link href="/2023/01/13/%E9%97%9C%E6%96%BC-JS-%E6%A8%A1%E7%B5%84%E5%8C%96%EF%BC%9ACMJ-AMD-CMD-UMD-ESM-IIFE/"/>
    <url>/2023/01/13/%E9%97%9C%E6%96%BC-JS-%E6%A8%A1%E7%B5%84%E5%8C%96%EF%BC%9ACMJ-AMD-CMD-UMD-ESM-IIFE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看第三方工具文件、研究 JavaScript 打包工具時，總有意無意看見這類技術名詞，CommonJS、AMD、UMD、ESM⋯⋯等。</p><p>就在好好研究後，才發覺『這些知識應該作為學習打包工具前的背景知識』。那麼讓我們開始吧！</p><h2 id="時代背景"><a href="#時代背景" class="headerlink" title="時代背景"></a>時代背景</h2><p>JavaScript 語言最早是為了解決網頁能和瀏覽器之間互動的問題而被發明的，輕便、容易使用成了設計他的目的。</p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript modules - A background on modules | MDN</a></p></blockquote><p>因此，在當時 JS 並沒有『模組化』的相關語法，我們的代碼全部處在同一個全域環境。隨著，網頁的開發越來越複雜，這樣的環境在維護上帶來許多不便。最後開發者社群，開始依照規範實作出『模組化』的方式。這也是我們看到 CommonJS、AMD、CMD、UMD、ESM 這麼多不同方式的原因。</p><p>回到現今 2023，身為一個前端開發人員，我們究竟要學習什麼？我想作為入門來說，我們可以把重點放在 ESM，並且大概了解其於 CommonJS、AMD、CMD、UMD 這些名詞的概念即可！</p><blockquote><p>推薦閱讀：<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a></p></blockquote><h2 id="CMJ-CommonJS"><a href="#CMJ-CommonJS" class="headerlink" title="CMJ - CommonJS"></a>CMJ - CommonJS</h2><p>CommonJS 專案在 2009 年 1 月由 Mozilla 工程師 Kevin Dangoor 建立，並且一開始的名稱為 ServerJS。目的是為了，在瀏覽器的環境之外建立 JavaScript 生態系，其中著名的應用環境就是 Node.js。在 CommonJS 中，使用 <code>require()</code> 函式來引用模組，<code>module.exports</code> 來導出。</p><p>我們需要知道的是，CommonJS 只用於服務端（Node.js）環境中，並不能用於瀏覽器環境。如果要將其使用在瀏覽器環境下，我們必須透過 JavaScript Module Loader 來替我們處理（引入 <code>require.js</code> 庫，並指定主文件入口）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&quot;scripts/main&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;scripts/require.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>關於 RequireJS 的更多訊息：<a href="https://requirejs.org/">A JavaScript Module Loader</a></p></blockquote><h2 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD - Asynchronous Module Definition"></a>AMD - Asynchronous Module Definition</h2><p>在服務端有了 CommonJS 解決模組化的問題後，瀏覽器端則是出現了 AMD 的解決方案。從名稱我們大概就可以猜到，它提供『異步』加載模組的方式。比起 CommonJS 以同步的方式來加載模組，受限於網速、並發數等的瀏覽器環境更為適合。在語法使用上，引入／導出 分別用 <code>require</code> 和 <code>define</code>。</p><p>要在瀏覽器端使用 AMD 的話，我們有幾種選擇：</p><ul><li><a href="https://requirejs.org/">RequireJS</a></li><li><a href="https://github.com/cujojs/curl">curl</a></li><li><a href="https://github.com/zazl/lsjs">lsjs</a></li><li><a href="https://dojotoolkit.org/">Dojo 1.7+</a></li></ul><p>同樣於瀏覽器中引入庫文件，並指定主文件入口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- example require.js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">data-main</span>=<span class="hljs-string">&quot;scripts/main&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;scripts/require.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>關於 AMD 更多訊息：<a href="https://requirejs.org/docs/whyamd.html#youcando">What You Can Do - Why AMD ?</a></p></blockquote><h2 id="CMD-Common-Module-Definition"><a href="#CMD-Common-Module-Definition" class="headerlink" title="CMD - Common Module Definition"></a>CMD - Common Module Definition</h2><p>CMD 本身和 AMD 相類似，同樣為具有『異步』的特性。差別在於：</p><ul><li>AMD: 依賴前置，在依賴模塊加載完畢後，即調用回調函式（你的代碼）</li><li>CMD: 依賴後製，在依賴模塊家載完畢後，不會立即調用回調函式；而是，當主函式執行後且使用到時才運行。</li></ul><p>要使用 CMD，我們需要使用 <a href="https://github.com/seajs/seajs">sea.js</a> 這個 Module Loader。</p><blockquote><p>關於 Sea.js 更多資訊 <a href="https://seajs.github.io/seajs/docs/en.html">Why use Sea.js ?</a></p></blockquote><h2 id="UMD-Universal-Module-Definition"><a href="#UMD-Universal-Module-Definition" class="headerlink" title="UMD - Universal Module Definition"></a>UMD - Universal Module Definition</h2><p>UMD 被設計用來同時使用在服務端、瀏覽器端。它整合了 AMD 和 CommonJS，大多數時候使用 AMD，在少數特別的情況使用 CommonJS 處理。</p><blockquote><p>關於 UMD 更多資訊 <a href="https://github.com/umdjs/umd">Universal Module Definition</a></p></blockquote><h2 id="ESM-ES-Module-aka-ES6-Module-aka-ES2015-Module"><a href="#ESM-ES-Module-aka-ES6-Module-aka-ES2015-Module" class="headerlink" title="ESM - ES Module aka ES6 Module aka ES2015 Module"></a>ESM - ES Module aka ES6 Module aka ES2015 Module</h2><p>ECMAScript 標準在 ES6 (aka ES2015) 加入了『模組化』的語法，<code>import</code>／<code>export</code>；然而，在當時的瀏覽器環境中尚未實作這樣的機制，因此，為了解決這樣的問題，社群開發出各式各樣的打包工具：<code>Webpack</code>、<code>Rollup</code> 等，讓我們在 Node.js 環境下使用 ES Module 的模組化語法。</p><blockquote><p>所以實際上我們使用的是 ES Module in Node.js，而後來瀏覽器環境實作的是 Native ES Module（有說錯再麻煩指教！）</p></blockquote><blockquote><p>進一步了解 Webpack <a href="https://blog.huli.tw/2020/01/21/webpack-newbie-tutorial/">webpack 新手教學之淺談模組化與 snowpack</a></p></blockquote><h2 id="IIFE-Immediately-Invoked-Function-Expression-Module"><a href="#IIFE-Immediately-Invoked-Function-Expression-Module" class="headerlink" title="IIFE - Immediately Invoked Function Expression Module"></a>IIFE - Immediately Invoked Function Expression Module</h2><p>用於 <code>&lt;script&gt;</code> 標籤，通常使用這樣的格式來作為打包網頁應用的結果。這樣的方式幫助我們避免變數名稱的衝突，以及保持代碼的私有性。</p><h2 id="編譯時期-vs-運行時期"><a href="#編譯時期-vs-運行時期" class="headerlink" title="編譯時期 vs 運行時期"></a>編譯時期 vs 運行時期</h2><p>在上述各種模組化工具中，在循環依賴上時存在差異，細節部分就沒有進一步研究，盼各位讀者自行深入。</p><p>而其中，ESM 和其於的模組化方式最為不同的在於，ESM 在編譯時期進行『符號（記憶體位置？）的引用』，而其他則是在執行時期進行『對象的引用』。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><blockquote><p>目前而言只使用過 CommonJS、ES Module，對於其他的模組化方式只有淺薄的了解，若讀者有興趣可以參考文章中各個連結，進一步深入。</p></blockquote><p>JavaScript 為了能夠在『服務端、瀏覽器端』達成模組化，經歷了一段路程。</p><p>在了解這段歷史之後，我們對於為什麼使用打包工具、以及 JS 模組化是什麼都有了解答。</p><p>最後讓我們簡單整理下各種『模組化』的技術可以使用在哪些環境上：</p><table><thead><tr><th align="center">-</th><th align="center">AMD</th><th align="center">CommonJS</th><th align="center">UMD</th><th align="center">CMD</th><th align="center">ES Module</th></tr></thead><tbody><tr><td align="center">Browser</td><td align="center">😄</td><td align="center">❌</td><td align="center">😄</td><td align="center">😄</td><td align="center">😄</td></tr><tr><td align="center">Server</td><td align="center">❌</td><td align="center">😄</td><td align="center">😄</td><td align="center">❌</td><td align="center">😄</td></tr><tr><td align="center">Async</td><td align="center">😄</td><td align="center">❌</td><td align="center">😄</td><td align="center">😄</td><td align="center">😄</td></tr></tbody></table><ul><li>CommonJS 要使用於瀏覽器環境，必須使用相關的套件、工具（RequireJS, Browserify）</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules</a></li><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a></li><li><a href="https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62">https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62</a></li><li><a href="https://requirejs.org/">https://requirejs.org</a></li><li><a href="https://juejin.cn/post/6956117965620117541#heading-6">https://juejin.cn/post/6956117965620117541#heading-6</a></li><li><a href="https://blog.huli.tw/2020/01/21/webpack-newbie-tutorial/">https://blog.huli.tw/2020/01/21/webpack-newbie-tutorial/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Module, CMJ, AMD, UMD, CMD, ESM, IIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>懵懂 Webpack 5 (React)</title>
    <link href="/2022/12/26/%E6%87%B5%E6%87%82-Webpack-5-React/"/>
    <url>/2022/12/26/%E6%87%B5%E6%87%82-Webpack-5-React/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>『網頁前端』的基礎是 HTML、CSS、JavaScript，通常情況下，很好理解和上手；然而，在某一天我們接觸了『前端框架』，可能是 Vue、React、或 Angular，突然間我們就變笨了。</p><p>學習 React 時，使用 <code>create-react-app</code> 這個工具，一下子就可以幫你把整個 React 開發環境建構好。接著，你只要在熟悉下 JSX 語法，很快就可以開始製作你的 SPA 網頁了。</p><blockquote><p><code>create-react-app</code>：React 官方提供的快速建構專案工具（不推薦使用於正式環境）</p></blockquote><blockquote><p><a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> 全稱 JavaScript XML，讓我們能夠在 JavaScript 中撰寫 HTML 的語法；但是注意他不是 HTML 也不是字串，這樣的語法會透過特定的編譯器（ex. Babel），轉譯成合法的 JavaScript 語言。</p></blockquote><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/SPA">SPA</a> 全稱 Single-page application，單頁應用。意思就是，網頁只存在單一個文件（HTML 檔），並透過 JavaScript APIs 來置換其中內容，達成換頁的效果。</p></blockquote><p>那麼這些事情，究竟和 Webpack 有什麼關係呢？學習 Webpack 可以幹嘛？</p><p>首先，我想當然是，你會更了解專案的建構過程；再來也是最大的好處，就是可以自行掌握『專案需要引入的工具、進行各種優化、和開發環境設定』。</p><p>如果你像我一樣想要『掌控整個專案、理解背後的建構流程』，那麼我建議你：</p><ul><li>重新手動建構一個小專案，不要使用 <code>create-react-app</code> 或任何建構工具</li><li>從閱讀 <a href="https://webpack.js.org/concepts/">Webpack: Concepts</a> 官方文件開始，跟著動手做</li></ul><blockquote><p>從官方文件學習的好處之一就是，你可以不用擔心資訊正確性的問題；然而，如果你覺得有必要，也可以試著搜集下其他不同的資訊，從多方面來了解。</p></blockquote><p>這是一段有點艱澀的路，但堅持下去。很快你就會開始對於專案是如何被建構出來，有點感覺了！</p><p>在本篇文章中，我會試著從更高的層面開始，用淺白的話來解釋一些觀念，再回到文件中的基本概念，並附上相關連結。</p><p>通常情況下，你可能會在閱讀文件、動手實作中交替著切換直到你了解些什麼。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在開始前，如果你像我當初一樣，是個初次從 HTML&#x2F;CSS&#x2F;JavaScript 學習過來的小白，對於面前的一堆工具的技術名詞，只有頭昏的感覺。</p><p>那麼我們來思考一件事：</p><p>現在的我們想試圖理解，我們編寫的 React 專案是如何被『建構』出來，且得以運行於瀏覽器。</p><p>但讓我們換個方向思考：</p><p>什麼樣類型的檔案，得以運行於瀏覽器環境？恩⋯⋯不就是 HTML、CSS、JavaScript！？</p><p>至此，我們得到了某些線索：</p><p>『打包工具（Bundler），最終必須生成出 HTML、CSS、JavaScript 這類的檔案，網頁才得以運行，對吧？』。</p><p>有了這樣的切入點後，我們就可以開始學習 Webpack 了！</p><blockquote><p>在 2022 的今天，除了 Webpack 也存在著其他前端的建構工具，諸如：esbuild、parcel、rollup 等。</p></blockquote><h2 id="建構（Build）"><a href="#建構（Build）" class="headerlink" title="建構（Build）"></a>建構（Build）</h2><p>在開始進入正題前，我們先感受下『建構 build』的結果，或是稱作『打包 bundle』的結果。</p><blockquote><p>這邊都是用 React 來舉例，但你要知道的是 Webpack 不單只可以使用於 React 專案。</p></blockquote><p>如我們猜測一樣，Webpack 會將我們的 React 專案『建構』出 HTML、CSS、JavaScript 檔案，這邊你只需要理解我們模組化的多個檔案，已經被『打包』也就是揉成一團，以可以運行於瀏覽器的形式重新出現了。</p><blockquote><p>CSS 的部分可能會被處理在 JavaScript 檔案中，而沒有出現；如果你遇到這樣的問題，很正常。</p></blockquote><p>接著如果你要進行『網站部署』，你只需要找有提供『靜態網站』建置服務的服務商即可。你可能會選擇 AWS S3、或是 GitHub Page 來實作，這些服務都有一定的免費使用量，讓你進行『免費 Free』的建置。</p><p>至此，當初的我仍然感覺到有些違和感。如果你也是從 PHP 這類使用 SSR 製作網頁過來的話，可能也會有同樣的感覺。</p><blockquote><p>SSR 全稱 Server-Side Rendering</p></blockquote><p>怎麼說呢？就是比起正常的伺服器運作，使用靜態網站建構的 React 應用，似乎哪簡單了點？</p><p>恩⋯⋯的確不止如此，Webpack 為我們做的事情其實更多，讓我們稍微深入『打包』這件事，究竟打包了什麼東西？</p><blockquote><p>你可以參考文件獲得更多訊息：<a href="https://webpack.js.org/concepts/manifest/">Webpack: Manifest</a></p></blockquote><p>一般情況下，會有三件東西被打包進最終的結果：</p><ul><li>你寫的 Code</li><li>第三方套件</li><li>Webpack Runtime 和 Manifest</li></ul><p>而 Webpack Runtime 就是，我們感到違和感的地方。這是 Webpack 替我們實作的機制，正常情況下我們感受不到他。</p><p>使用者請求我們的網站時，Runtime 會於客戶端中（也就是瀏覽器中）運行起來，依據使用者的行為，於瀏覽器中載入相對應的模組（你可以理解成頁面）。</p><blockquote><p>舉例來說，當你今天使用 lazy loading 分離了『網站的主頁』和『商品頁』，在使用者訪問主頁時，Runtime 並不會為我們向靜態伺服器請求『商品頁』相關的代碼；而是在使用者點擊相關路由後，Runtime 才進行請求，以此加快網頁載入速度、減少流量傳輸。</p></blockquote><p>所以，原理上仍相同，對於 前後端整合在一起的網站（ex. PHP）來說，『路由』是被實現於後端（伺服器端），依據前端（客戶端）的請求回傳特定的資源；而像 前後端分離（ex. React）這類的專案，『路由』則是被實現於前端（瀏覽器中），再依據使用者的行為，向『靜態伺服器』請求新的頁面，或是向『後端伺服器』請求特定的資料。</p><blockquote><p>前後端分離的專案，後端也有自己的路由</p></blockquote><p>至此，我們對於整個 React 專案，從『建構 Build』或者稱作『打包 Bundle』到『部署 Deploy』皆有了概觀的認識了。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Webpack 打包工具有著幾項基本概念：</p><ul><li>Entry</li><li>Output</li><li>Loaders</li><li>Plugins</li><li>Mode</li><li>Browser Compatibility</li><li>Environment</li></ul><p><a href="https://webpack.js.org/concepts/">官方文件</a>有著非常詳盡的解釋，以及範例。</p><p>我們只會進行簡單的介紹，讓你不這麼陌生。在建構專案的大多數時候，你會不斷在 Webpack 官網提供的文件中，尋找可用的工具。</p><h3 id="Entry-amp-Output"><a href="#Entry-amp-Output" class="headerlink" title="Entry &amp; Output"></a>Entry &amp; Output</h3><p>Entry 和 Output 屬性，用來設定整個『打包』過程的輸入和輸出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./src/index.tsx&#x27;</span><br>    &#125;,<br><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/js/[name].[contenthash].bundle.js&#x27;</span>,<br>        <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Entry：可以接受多可打包入口（你的應用程式入口），Webpack 會從這個檔案開始分析檔案間的依賴性，並進行打包。</li><li>Output：設定打包結果檔案，輸出的位置、名稱、方式。此處的 <code>[name]</code> 和 <code>[contenthash]</code> 是會被替換的變數。在此例中，<code>[name]</code> 會被替換成 <code>main</code>，而 <code>[contenthash]</code> 會被替換成，依檔名和內容計算出來的 hash 值。</li></ul><blockquote><p>更多關於 <a href="https://webpack.js.org/configuration/entry-context/">entry</a> 和 <a href="https://webpack.js.org/configuration/output/">output</a> 內容</p></blockquote><h3 id="Loaders-amp-Plugins"><a href="#Loaders-amp-Plugins" class="headerlink" title="Loaders &amp; Plugins"></a>Loaders &amp; Plugins</h3><p>Loaders 和 Plugins 大概是最常用到的屬性。</p><p>在預設情況下 Webpack 只能讀取 JavaScript 和 JSON 檔案；然而，在專案中有著各種類型的檔案等著我們匯入。</p><p>因此，我們必須借助各種各樣的 Loader 來轉譯這類型的檔案，使其成為 Webpack 能夠讀取的合法模塊。</p><ul><li><p>Loader：通常由第三方社群維護，用於轉換不同類型的模塊。在實際得使用上，Loader 像是 Webpack 與其他工具整合的橋樑。</p><p>  舉例來說：我們可以使用 Babel 工具單獨來編譯 JSX 語法、轉換出 ES5 語法；但是要將工具整合進 Webpack 的打包流程中時，我們就必須使用 <code>babel-loader</code> 這個第三方工具來完成。</p><p>  值得注意得是，真正進行 JSX 語法⋯⋯等編譯得仍是 Babel 工具，我們一樣可以藉由撰寫 <code>babel.config.json</code> 設定檔來，改變 Babel 的行為。（<code>babel-loader</code> 也有提供 <code>options</code> 屬性給我們進行設定，使用哪種方式取決開發人員）</p><blockquote><p>Webpack 官方有列出相關的 <a href="https://webpack.js.org/loaders/">Loader 清單</a></p></blockquote><p>  在實際設定檔的編寫上，loader 會被定義於 <code>module.rules</code> 屬性中。</p><ul><li><code>test</code>：定義哪些類型的檔案需要進行處理</li><li><code>use</code>：定義由哪些 loader 來處理。可以注意到的是 <code>use</code> 接收一個數組，而 loader 實際處理的順序是由右至左，表示越需要優先處理的 loader 要擺越後面。</li></ul><blockquote><p>觀察 CSS 的 Loader，模塊被轉換的順序是：<code>postcss-loader</code> &gt; <code>css-loader</code> &gt; <code>MiniCssExtractPlugin.loader</code></p></blockquote><blockquote><p>在 Webpack 5 中，對於引入圖片、影片、字型，使用內建的 Asset Module 模組進行處理即可，不需要在像過去額外引入 loader，詳細請參考 <a href="https://webpack.js.org/guides/asset-management/#loading-images">Webpack: Asset Management</a></p></blockquote><p>  讓我們看範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            <span class="hljs-comment">// JavaScript</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?jsx?$/i</span>,<br>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;babel-loader&#x27;</span>]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?tsx?$/i</span>,<br>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;ts-loader&#x27;</span>]<br>            &#125;,<br>            <span class="hljs-comment">// CSS</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s?[ac]ss$/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]<br>            &#125;,<br>            <span class="hljs-comment">// Assets</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|jpeg|gif|mp4|pdf|mpg)$/i</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br>                <span class="hljs-attr">generator</span>: &#123;<br>                    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/media/[name][hash][ext][query]&#x27;</span><br>                &#125;<br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/i</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br>                <span class="hljs-attr">generator</span>: &#123;<br>                    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/font/[name][hash][ext][query]&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Plugin：其中有官方維護的，也有由第三方社群維護，用於處理更廣泛的任務，打包優化、資源管理、注入環境變量等。</p><p>  和 Loader 一樣，官方同樣整理出了一份清單，介紹各種 Plugin 的使用。</p><blockquote><p><a href="https://webpack.js.org/plugins/">Webpack: Plugins</a></p></blockquote><p>  Plugin 在使用上也是，需要時翻找文件一邊參考一邊設定即可。</p><p>  快速介紹幾種常見的 Plugin </p><ul><li><code>HtmlWebpackPlugin</code>：用於處理、生成 HTML 檔，來服務打包的結果（.js）</li><li><code>MiniCssExtractPlugin</code>：用於抽離 CSS 代碼成單獨的檔案</li><li><code>CssMinimizerPlugin</code>：（優化）最小化 CSS 代碼</li><li><code>TerserPlugin</code>：（優化）最小化 JS 代碼</li><li><code>BundleAnalyzerPlugin</code>：（優化）分析打包結果</li></ul><p>  讓我們看範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;public/index.html&#x27;</span>),<br>            <span class="hljs-attr">favicon</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;public/favicon.png&#x27;</span>),<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/css/[name].[contenthash].css&#x27;</span>,<br>            <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;static/css/[id].[contenthash].css&#x27;</span>,<br>        &#125;)<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>要手動自行編寫 Webpack 設定檔，是一件繁瑣的事情。在起步的開始，會需要看一堆 Loader、Plugin、和其他工具的文件，釐清每一個工具實際負責處理哪個部分，然後進行安裝。</p><p>建議從小專案開始，一次整合一種工具，一段時間後會開始了解每種工具的職責。希望本文章能為你學習 Webpack 5 達到引導的效果。</p><p>最後附上自己使用中的設定檔，以供參考：</p><details><summary>package.json</summary><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br><span class="hljs-punctuation">&#123;</span><br>    ...<br>    <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack s --env mode=dev -c ./webpack.dev.js&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --env mode=prod -c ./webpack.prod.js&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;prod&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http-server --port 3000 -P http://localhost:3000? ./build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></details><details><summary>webpack.common.js</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.common.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./src/index.tsx&#x27;</span><br>    &#125;,<br><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;public/index.html&#x27;</span>),<br>            <span class="hljs-attr">favicon</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;public/favicon.png&#x27;</span>),<br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/css/[name].[contenthash].css&#x27;</span>,<br>            <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;static/css/[id].[contenthash].css&#x27;</span>,<br>        &#125;)<br>    ],<br><br><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            <span class="hljs-comment">// JavaScript</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?jsx?$/i</span>,<br>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;babel-loader&#x27;</span>]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?tsx?$/i</span>,<br>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;ts-loader&#x27;</span>]<br>            &#125;,<br>            <span class="hljs-comment">// CSS</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s?[ac]ss$/i</span>,<br>                <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]<br>            &#125;,<br>            <span class="hljs-comment">// Assets</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|jpeg|gif|mp4|pdf|mpg)$/i</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br>                <span class="hljs-attr">generator</span>: &#123;<br>                    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/media/[name][hash][ext][query]&#x27;</span><br>                &#125;<br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/i</span>,<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br>                <span class="hljs-attr">generator</span>: &#123;<br>                    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/font/[name][hash][ext][query]&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>    &#125;,<br><br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-attr">components</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/components&#x27;</span>),<br>            <span class="hljs-attr">hooks</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src/hooks&quot;</span>),<br>            <span class="hljs-attr">pages</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src/pages&quot;</span>),<br>            <span class="hljs-attr">utils</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src/utils&quot;</span>),<br>            <span class="hljs-attr">styles</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src/styles&quot;</span>),<br>            <span class="hljs-attr">images</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src/images&quot;</span>),<br>            <span class="hljs-attr">contexts</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/contexts&#x27;</span>),<br>            <span class="hljs-attr">store</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/store&#x27;</span>),<br>            <span class="hljs-attr">api</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/api&#x27;</span>),<br>            <span class="hljs-attr">mocks</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src/mocks&#x27;</span>)<br>        &#125;,<br>        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.tsx&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>]<br>    &#125;,<br><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/js/[name].[contenthash].bundle.js&#x27;</span>,<br>        <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><details><summary>webpack.dev.js</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Dotenv</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv-webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;env :&gt;&gt; &#x27;</span>, env);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(common, &#123;<br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br><br>        <span class="hljs-attr">plugins</span>: [<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dotenv</span>(&#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">`./.env.<span class="hljs-subst">$&#123;env.mode&#125;</span>`</span><br>            &#125;)<br>        ],<br><br>        <span class="hljs-attr">output</span>: &#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;static/js/[name].bundle.js&#x27;</span>,<br>            <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>            <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>            <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>        &#125;,<br><br>        <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,<br><br>        <span class="hljs-attr">devServer</span>: &#123;<br>            <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>            <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">historyApiFallback</span>: &#123;<br>                <span class="hljs-attr">disableDotRule</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// for using dot in url path</span><br>            &#125;, <span class="hljs-comment">// redirect 404 to index.html</span><br>            <span class="hljs-attr">headers</span>: &#123;<br>                <span class="hljs-comment">// for google-sign-in button popup mode.</span><br>                <span class="hljs-string">&#x27;Cross-Origin-Opener-Policy&#x27;</span>: <span class="hljs-string">&#x27;same-origin-allow-popups&#x27;</span>,<br>                <span class="hljs-comment">// &#x27;Cross-Origin-Opener-Policy&#x27;: &#x27;same-origin&#x27;,</span><br>                <span class="hljs-comment">// &#x27;Cross-Origin-Embedder-Policy&#x27;: &#x27;require-corp&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></details><details><summary>webpack.prod.js</summary><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Dotenv</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv-webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;env :&gt;&gt; &#x27;</span>, env);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(common, &#123;<br>        <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<br>        <span class="hljs-attr">plugins</span>: [<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dotenv</span>(&#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">`./.env.<span class="hljs-subst">$&#123;env.mode&#125;</span>`</span><br>            &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(),<br>        ],<br><br>        <span class="hljs-attr">optimization</span>: &#123;<br>            <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123; <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span> &#125;)],<br>            <span class="hljs-attr">splitChunks</span>: &#123;<br>                <span class="hljs-attr">cacheGroups</span>: &#123;<br>                    <span class="hljs-attr">react</span>: &#123;<br>                        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](react|react-dom|react-router-dom)[\\/]/</span>,<br>                        <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vendor~react&#x27;</span>,<br>                        <span class="hljs-attr">enforce</span>: <span class="hljs-literal">true</span>,<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></details>]]></content>
    
    
    
    <tags>
      
      <tag>webpack, react, vue, babel, bundler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google 第三方登入(JavaScript + Node.js)</title>
    <link href="/2022/12/18/Google-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%85%A5-JavaScript-Node-js/"/>
    <url>/2022/12/18/Google-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%85%A5-JavaScript-Node-js/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先記錄下文章，以及實作時間均在 2022 年，作為讀者判斷資料內容時效性的參考。</p><h3 id="初心"><a href="#初心" class="headerlink" title="初心"></a>初心</h3><p>2021 年 10 月，當時報名參加了資展國際舉辦的 前端工程師就業養成班。在課程開始後不久，馬上就收到分組以及決定期末專題製作方向的通知了。</p><p>還記得當時，第一個念頭就是想實作 Google 第三方登入，總覺能夠透過 API 穿梭在互聯網中很酷；然而，可惜的是課程的進度，以及專案時程的壓力，並沒有太多餘力好好研究第三方登入的內容。</p><h3 id="沈澱"><a href="#沈澱" class="headerlink" title="沈澱"></a>沈澱</h3><p>在結束為期半年的培訓後，終於鬆了一口氣了，同學也陸續開始找尋就業機會；而我也開始思索著下一步怎麼走，同時也有了一段時間可以好好研究 Google 第三方登入。</p><h3 id="碰壁"><a href="#碰壁" class="headerlink" title="碰壁"></a>碰壁</h3><p>一直以來的習慣，面對完全陌生的技術時（或是只想懶懶的學習時），就會試著找 Youtube 視頻教學，讓別人來教我怎麼做（這時候就知道學生時期在教室的幸福）。</p><p>然而，很快就發現，這些視頻教學（包括 Google 官方的視頻），似乎哪裡怪怪的，是過期了嗎？意識到這點時，我大概知道只能認命的乖乖去找技術文件了！</p><p>技術文件的內容的編排方式讓我花了點時間才搞懂，哪些才是需要看的。</p><p>總之，簡單來說目前有 2 份，一份是在講舊版的 JS 庫串接方式、一份是新版的，如果你是新手記得不要看到舊版的。</p><ul><li><a href="https://developers.google.com/identity/sign-in/web/sign-in">Goggle 第三方登入 舊版 - 只支援到 March 31, 2023</a></li><li><a href="https://developers.google.com/identity/gsi/web/guides/overview">Google 第三方登入 新版</a></li></ul><blockquote><p>舊版，雖然說支援到 2023&#x2F;03&#x2F;31，如果你的 client_id 比較新，在引入庫時要記得加上 plugin_name (文件開頭有說自己看)</p></blockquote><p>那麼接下來，介紹的實作方式環境如下：</p><ul><li>前端： HTML or JavaScript</li><li>後端： Node.js</li><li>實作：Google Sign In With Button</li></ul><p>那麼讓我們開始吧！</p><h2 id="快速導覽"><a href="#快速導覽" class="headerlink" title="快速導覽"></a>快速導覽</h2><p>這個章節會簡單介紹一些概念、放上相關連結。</p><p>基本上這個章節的內容，就是將原文件中重點部分抽離出來簡單介紹，所以如果你想自己動手實作，推薦自己閱讀完整的文件內容。</p><h3 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h3><p>本文章所有關於 Google 官方技術文件連結，按照提及順序排列。</p><blockquote><p>巢狀表示，子連結內容你自己也可以在父連結頁面中找到。</p></blockquote><ul><li><a href="https://developers.google.com/identity/gsi/web/guides/overview">Sign In with Google for Web</a><ul><li><a href="https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid">Setup</a></li><li><a href="https://developers.google.com/identity/gsi/web/guides/choose-components">Choose Sign In With Google components for your pages</a></li><li><a href="https://developers.google.com/identity/gsi/web/reference/html-reference">Refrence: HTML API</a></li><li><a href="https://developers.google.com/identity/gsi/web/reference/js-reference">Refrence: JavaScript</a></li><li><a href="https://developers.google.com/identity/gsi/web/guides/verify-google-id-token">Verify the Google ID token on your server side</a></li><li><a href="https://developers.google.com/identity/gsi/web/guides/migration">Migrating from Google Sign-In</a>。</li><li><a href="https://developers.google.com/identity/gsi/web/tools/configurator">Code Generator</a></li></ul></li><li><a href="https://console.developers.google.com/apis">Google APIs console</a></li><li><a href="https://jwt.io/introduction">JWT (Json Web Token)</a></li></ul><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>設定你的 <a href="https://console.developers.google.com/apis">Google APIs console</a>，如果你還沒有帳號記得先註冊。</p><p>這裡主要有 2 件事情要完成：</p><ul><li>在你的 <strong>Credentials</strong> 頁面中 創建屬於你的 <strong>OAtuh 2.0 Client ID</strong></li><li>設定你 <strong>Client ID</strong> 的 <strong>Authorized JavaScript origins</strong> 或 <strong>Authorized redirect URIs</strong>，取決你的 UX 是採 popup 流程還是 redirect（也可以都設定）</li></ul><p>Client ID 會是一串代碼，在我們引用 GSI 庫時會使用到。而 <strong>Authorized JavaScript origins</strong> 我們通常會將本地環境、和正式環境的 domain 都加入；值得注意得是，本地環境記得 <code>http://localhost</code> 和 <code>http://localhost:&lt;port_number&gt;</code> 兩個都要設定。</p><p>其餘的設定就是 <strong>OAuth Consent Screen</strong>，這個部分就是用來提示 你的網站使用者，你是誰、會取用哪些以及如何利用 使用者的資料。</p><p>其他更近一步詳細資訊，請參考 <a href="https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid">Setup</a></p><h3 id="Load-the-client-library"><a href="#Load-the-client-library" class="headerlink" title="Load the client library"></a>Load the client library</h3><p>在你的前端網頁，以 CDN 的方式載入 <code>GSI</code> 庫（Google Identity Services）。我也不知道為什麼不叫 <code>GIS</code> 而是 <code>GSI</code>。</p><blockquote><p>GSI 是一個只提供給前端環境使用的庫，只能使用 CDN 方式載入。</p></blockquote><blockquote><p>目前有 One Tap、Sign In With Button 這 2 種實作方式。這兩種差別請參考 <a href="https://developers.google.com/identity/gsi/web/guides/choose-components">Choose Sign In With Google components for your pages</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://accounts.google.com/gsi/client&quot;</span> <span class="hljs-attr">async</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>GSI</code> 庫載入成功後，會在你的前端環境創建名為 <code>google</code> 的全域物件。</p><p>如果你想使用 JavaScript 的方式實作，你將會使用 <code>google</code> 物件來初始化；但如果你使用 HTML 方式來實作，你可以不用理會這個物件，直接將相關資料填入指定的 <code>data-*</code> 屬性即可。</p><p>這時候會需要參考到的 技術文件：</p><ul><li><a href="https://developers.google.com/identity/gsi/web/reference/html-reference">Reference: HTML</a></li><li><a href="https://developers.google.com/identity/gsi/web/reference/js-reference">Reference: JavaScript</a></li></ul><p>初始化要做的事情主要有 2 件（沒提到的請自行參考上方文件）</p><blockquote><p>這裡介紹的是 Google Sign In With Button 方式。One Tap 自己本身還沒實作過，請自行參考文件。</p></blockquote><ul><li>設定你的 <strong>Client ID</strong>，這將與你的 Google APIs console 連結起來</li><li>設定 UX 流程是 <strong>popup</strong> 或是 <strong>redirect</strong><ul><li><strong>popup</strong>: 將使用者的 JWT 傳到前端，這時你必須設定 <code>callback</code> 來處理接收到的 Token，在自行傳到後端進行驗證、資料庫處理等。（通常用於前後端分離專案）</li><li><strong>redirect</strong>: 將使用者的 JWT 導向你的後端，你可以直接在後端進行驗證、資料庫處理等。</li></ul></li></ul><blockquote><p><a href="https://jwt.io/introduction">JWT (Json Web Token)</a>。如果不知道是什麼，還需要自行補上這塊背景知識。</p></blockquote><p>基本上到這，大概就完成了。就只剩下實作 JWT decode（自行選擇適合的庫，上方 JWT 官網有清單）、使用 <code>OAuth2Client</code> (Node.js 環境) 來驗證 Token 有效性、CSRF 防止 ⋯⋯ 等。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>如果你想快速感覺下整個流程，推薦你使用 HTML 的方式 先實作前端的部分即可。直接將你的 <strong>Client ID</strong> 和 <strong>Callback</strong> (用來處理 Token 回傳的函式) 設定好就可以看看你拿到的 Token 長什麼樣子。</p><p>如果你想了解舊版和新版的差異，文件說明在這 <a href="https://developers.google.com/identity/gsi/web/guides/migration">Migrating from Google Sign-In</a>。</p><p>另外這裡有 HTML 實作方式的按鈕產生器，可以幫你把基本資料都填好。<a href="https://developers.google.com/identity/gsi/web/tools/configurator">Code Generator</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gsi, google</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 世界起源下（原型鏈）</title>
    <link href="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/"/>
    <url>/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/">JavaScript 世界起源上（原型鏈）</a>中，我們已經介紹完原型鏈的基本觀念</p><p>有了基本的認識後，在本章我們將實際建構『原型鏈』並且實作『函式 function』和『語法糖 class』兩種方式</p><p>實際上使用 <code>class</code> 來創建物件，和傳統使用『函式』，仍有些微的差異，並且 <code>class</code> 還擁有些擴展的性質</p><blockquote><p>推薦閱讀 <a href="https://javascript.info/class">Class basic syntax | JavaScript.info</a></p></blockquote><p>那麼，讓我們分別從幾個角度來比較『傳統使用函式』和『現在使用 class』的差異</p><ul><li>建構式</li><li>建構原型</li><li>原型繼承</li></ul><blockquote><p>如果忘記 <code>new</code> 運算子究竟做了哪些工作的，可以回顧下『JavaScript 世界起源上（原型鏈）』</p></blockquote><h2 id="建構式-constructor"><a href="#建構式-constructor" class="headerlink" title="建構式 constructor"></a>建構式 constructor</h2><p><strong>function</strong></p><ul><li>宣告一個函式，命名習慣以大寫字母開頭（表示建構式）</li><li>使用 <code>this</code> 關鍵字來為物件添加屬性、方法</li></ul><p><strong>class</strong></p><ul><li>使用 <code>class</code> 關鍵字，宣告類（語法糖）</li><li>定義 <code>constructor</code> 函式（建構式）</li></ul><p><a href="constructor.js">constructor.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CUser</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">const</span> cUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CUser</span>(<span class="hljs-string">&#x27;CLiz&#x27;</span>, <span class="hljs-number">6</span>);<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;user :&gt;&gt; &#x27;</span>, user);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cUser :&gt;&gt; &#x27;</span>, cUser);<br></code></pre></td></tr></table></figure><p>讓我們看下在瀏覽器中（Safari 15.1）的執行結果</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/constructor.png" alt="constructor.png"></p><p>我們可以觀察到，2 種方式創建出來的物件</p><ul><li>都擁有自己的屬性 <code>name</code> 和 <code>age</code></li><li>分別繼承了原型 <code>User</code> 和 <code>CUser</code></li><li>原型 <code>User</code> 和 <code>CUser</code> 都擁有 <code>constructor</code> 屬性指向建構式</li><li>原型 <code>User</code> 和 <code>CUser</code> 都繼承自 Object 原型（<code>Object.prototype</code>）</li></ul><h2 id="建構原型-prototype"><a href="#建構原型-prototype" class="headerlink" title="建構原型 prototype"></a>建構原型 prototype</h2><p><strong>function</strong></p><ul><li>添加『原型屬性』，直接操作 <code>&lt;constructor&gt;.prototype</code> 即可</li><li>添加『原型方法』，直接操作 <code>&lt;constructor&gt;.prototype</code> 即可</li></ul><p><strong>class</strong></p><ul><li>添加『原型屬性』，操作 <code>&lt;constructor&gt;.prototype</code></li><li>添加『原型方法』，在 <code>class</code> 區塊當中宣告函式</li></ul><blockquote><p>大多數時候，我們較少為原型添加屬性</p></blockquote><p><a href="prototype.js">prototype.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 為原型添加屬性</span><br><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lang</span> = <span class="hljs-string">&#x27;en&#x27;</span>;<br><br><span class="hljs-comment">// 為原型添加方法</span><br><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// 靜態屬性、方法</span><br><span class="hljs-title class_">User</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;USA&#x27;</span>;<br><span class="hljs-title class_">User</span>.<span class="hljs-property">displayLocation</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this.location :&gt;&gt; &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">location</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CUser</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 為原型添加方法</span><br>    <span class="hljs-title function_">hi</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 靜態屬性、方法</span><br>    <span class="hljs-keyword">static</span> location = <span class="hljs-string">&#x27;USA&#x27;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">displayLocation</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this.location :&gt;&gt; &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">location</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 為原型添加屬性</span><br><span class="hljs-title class_">CUser</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">lang</span> = <span class="hljs-string">&#x27;zh&#x27;</span>;<br><br><br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">const</span> cUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CUser</span>(<span class="hljs-string">&#x27;CLiz&#x27;</span>, <span class="hljs-number">6</span>);<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;user :&gt;&gt; &#x27;</span>, user);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cUser :&gt;&gt; &#x27;</span>, cUser);<br></code></pre></td></tr></table></figure><p>讓我們看下在瀏覽器中（Safari 15.1）的執行結果</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/prototype.png" alt="prototype.png"></p><p>我們可以觀察到，兩種方式都分別成功的為 <code>User</code> 和 <code>CUser</code> 原型添加了 <code>lang</code> 屬性、和 <code>hi()</code> 方法</p><p>可以注意到的是我們增加了『靜態屬性、方法』，所謂的『靜態』指的是跟著 <code>User</code> 和 <code>CUser</code> 建構式物件本身</p><blockquote><p>靜態的屬性、方法，不存在於原型鏈當中；直接透過建構式物件訪問 ex. <code>User.location</code> or <code>CUser.displayLocation()</code></p></blockquote><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/static.png" alt="static.png"></p><h2 id="原型繼承-Prototypal-Inheritance"><a href="#原型繼承-Prototypal-Inheritance" class="headerlink" title="原型繼承 Prototypal Inheritance"></a>原型繼承 Prototypal Inheritance</h2><p>談論 JS 的原型繼承，大概是許多新手頭痛的問題之一，包括當初的自己在內。</p><p>首先，必須說 <code>class</code> 的出現其實解決了這樣一個的問題，我們只需要使用 <code>extends</code> 關鍵字即可讓 JS 幫助我們完成原型繼承的串連。</p><p>但是求知慾旺盛的我們，卻沒有因此滿足，所以，下方我們會列舉常見的繼承方式，深入研究之間的差異</p><p>在開始前，如果你曾學習過 OOP 相關的語言（ex. C++），也許你會很困惑，為什麼一個『繼承』也有這麼多方式？</p><p>我想這是我給自己的答案，你可以參考下：</p><p>『我們一再提及 JS 當中，只有物件 object 沒有 類 class 的概念，而在 JS 中取代 類 的繼承 inheritance 的機制，是所謂的原型繼承 prototypal inheritance』</p><p>那麼，這跟多種繼承方式的現象有什麼關係？</p><p>是因為『原型繼承的本質』</p><p>『原型繼承，就像是有這麼一群 原型物件 存在。原型物件 除了儲存著需要共享的數據，同時也紀錄著 另一個原型物件，就像是串列 List 這樣的資料結構（鏈狀結構），一個接著一個，直到盡頭（指向 null）』</p><p>而每當我們創建 新物件（instance，實例物件），我只需要將這個 物件 中紀錄原型的地方，存進 特定一個原型物件，那麼就可以共享到這個 原型物件 以上（包含）的原型鏈中的數據了』</p><p>那麼重點來了，是誰在幫我們做這件事（連結原型鏈）？</p><ul><li>在傳統的方法中是 <code>new</code> 運算子 和 我們自己手動</li><li>在現在的方法中是 <code>new</code> 運算子 和 <code>class</code> 中的 <code>extends</code> 語法</li></ul><p>這個答案不知道，會不會有人覺得奇怪，『手動』什麼意思？還可以『自己訂規則』？</p><p>恩，就是這樣。我們可以『任意的操縱原型鏈』，只要我們想要，然而多數情況並不建議如此做</p><p>關於這點，並沒有太深入的查詢資料，只能說這是 JavaScript 這個語言給予的『彈性』</p><p>所以，出於這樣的原因，才會讓新手在查找資料時，找到各種各樣教學繼承的版本</p><p>那麼，今天就來一一討論這些各種各樣的繼承方式，究竟背後的『原型，彼此是怎麼關聯的』</p><p>由於這些方法沒有一個特定名子，所以會附上描述，而命名上會盡量簡潔</p><h3 id="建構式"><a href="#建構式" class="headerlink" title="建構式"></a>建構式</h3><p>利用函式原型（<code>Function.prototype</code>）提供的 <code>call()</code> or <code>apply()</code> 方法達成</p><blockquote><p>在 子物件 當中呼叫 父物件 建構式</p></blockquote><p><a href="inherit-constructor.js">inherit-constructor.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// Animal 原型</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">talk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabit</span>(<span class="hljs-params">name, color</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）中執行上述代碼</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-constructor.png" alt="inherit-constructor"></p><p>可以觀察到，這樣的方式的確可以使『物件實例』擁有 父物件建構式當中所定義的屬性，然而實際上並未達成『原型繼承』</p><p>所以，我認為這樣的繼承方式並不完整</p><p>讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-constructor-mind.png" alt="inherit-constructor-mind.png"></p><p>我們可以觀察到，兔子原型（<code>Rabit.prototype</code>）本該連結到 動物原型（<code>Animal.prototype</code>），但卻直接連回 物件原型（<code>Object.prototype</code>）了</p><blockquote><p>灰色虛線部分，為本應該連結的部分</p></blockquote><p>所以，很正常的 兔子實例 無法使用 動物原型 的 <code>talk()</code> 方法</p><h3 id="實例"><a href="#實例" class="headerlink" title="實例"></a>實例</h3><p>創建一個 父物件 的『實例』，將其作為 子物件 『原型』</p><p>讓我們看一下代碼：</p><p><a href="inherit-instance.js">inherit-instance.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// Animal 原型</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">talk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabit</span>(<span class="hljs-params">name, color</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-comment">// 創建 父物件 的 實例物件 作為（取代）子物件的原型</span><br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>;<br><span class="hljs-comment">// 這種方式，如果不指定 constructor 則會指向 父物件建構式 Animal</span><br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Rabit</span>;<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__ === Rabit.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__.__proto__ === Animal.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）中，執行上述代碼</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-instance.png" alt="inherit-instance"></p><p>可以看見，我們創建出來的 <code>rabit</code> 實例物件，成功地串連起 兔子原型（<code>Rabit.prototype</code>）、動物原型（<code>Animal.prototype</code>）、物件原型（<code>Object.prototype</code>）</p><p>為了更清楚的理解，讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-instance-mind.png" alt="inherit-instance-mind.png"></p><p>我們可以觀察到，兔子原型（<code>Rabit.prototype</code>）被 動物的實例物件（Animal instance）取代，而作為一個 實例 自然而然 可以訪問 原型（動物），因此整個『原型繼承』串連完成</p><blockquote><p>灰色虛線的兩端，是同一個物件（Animal 實例物件）</p></blockquote><p>至此，讓我們思考下這種方式存在什麼樣的問題</p><p>可以看見，使用 實例物件 取代 原型物件，這樣的方式造成：『多出一份用不到的數據（實例）佔據原型物件（兔子）的位置』</p><p>所以，如果忽略『多餘數據佔據空間的缺點』，這樣的方式『仍可以達成原型鏈的串接』</p><h3 id="取代"><a href="#取代" class="headerlink" title="取代"></a>取代</h3><p>直接將 父物件 的『原型』作為 子物件 的『原型』取代</p><p>讓我們看下代碼：</p><p><a href="inherit-replace.js">inherit-replace</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// Animal 原型</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">talk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabit</span>(<span class="hljs-params">name, color</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-comment">// 直接將 父物件 的原型 取代 子物件 的原型</span><br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-comment">// 這種方式，如果不指定 constructor 則會指向 父物件建構式 Animal</span><br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Rabit</span>;<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__ === Rabit.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__.__proto__ === Animal.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）中執行</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-replace.png" alt="inherit-replace"></p><p>這裡需要注意的是 log 中的 兔子原型（<code>Rabit Prototype</code>）實際上是 動物原型（<code>Animal Prototype</code>），從擁有 <code>talk()</code> 方法即可得知</p><blockquote><p>由於修改了 <code>Rabit.prototype.constructor = Rabit</code> 因此會有如上現象，如果不修改則會顯示 動物原型</p></blockquote><p>由於，原型的取代，使得原型鏈縮短，對於 <code>rabit</code> 實例來說，上方第二原型就回到 <code>Object.prototype</code>，所以我們 log 的結果為 <code>false</code></p><p>為了更清楚的理解，讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-replace-mind.png" alt="inherit-replace-mind.png"></p><p>我們可以觀察到，兔子原型（<code>Rabit.prototype</code>）被 動物原型（<code>Animal.prototype</code>）取代，因此整個『原型繼承』自然而然串接完成</p><blockquote><p>灰色虛線的兩端，是相同一個物件（動物原型 <code>Animal.prototype</code>）</p></blockquote><p>至此，讓我們思考下這種方式的優劣</p><p>原型的取代，讓整個原型鏈長度縮短，在原型鏈的訪問上效率更好</p><p>然而，顯而易見，兔子原型 不是一個獨立的物件（不像上方『實例』的方法），因此，所有對 兔子原型 的修改，實際上也影響著 動物原型 </p><p>所以，如果今天 子物件的原型 不會被更動，那麼也許可以使用這樣的方式來『達成原型鏈的串接』</p><h3 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h3><p>將 子物件 的原型，和 父物件 的原型『連結』(意思就是 子物件的原型物件 的原型是 父物件的原型物件)</p><p>讓我們看一下代碼：</p><p><a href="inherit-link.js">inherit-link</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// Animal 原型</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">talk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabit</span>(<span class="hljs-params">name, color</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-comment">// 將 Rabit 原型 連結 Animal 原型</span><br><span class="hljs-comment">// Rabit.prototype.__proto__ = Animal.prototype;</span><br><span class="hljs-comment">// OR</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__ === Rabit.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__.__proto__ === Animal.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）中執行上述代碼</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-link.png" alt="inherit-link"></p><p>這樣的方式，我們可以看到『原型鏈被完整的串接起來』。</p><p>而值得注意的是，代碼中 2 種連結的方式，由於 MDN 文件建議不要直接訪問 <code>__proto__</code> 因此，我們使用 <code>Object.setPrototypeOf()</code> 取代，兩種都是設定『自身物件』在『原型鏈的上方』要連結著誰（object）</p><p>為了更清楚的理解，讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-link-mind.png" alt="inherit-link-mind.png"></p><p>從心理模型中我們可以看到，兔子原型（<code>Rabit.prototype</code>）連接著 動物原型（<code>Animal.prototype</code>），完成『原型鏈的串接』</p><h3 id="創建"><a href="#創建" class="headerlink" title="創建"></a>創建</h3><p>『創建』一個以 父物件 的原型為原型 的物件，將其賦值給 子物件的原型</p><blockquote><p>實際上，『連結』與『創建』和『class（後續會待到）』所構建出來的原型鏈是一模一樣的</p></blockquote><p>創建的過程，我們會借助 <code>Object.create()</code> 這個內建方法完成</p><blockquote><p><code>Object.create()</code> 接受一個 物件 參數，將其作為原型 創建出一個新物件</p></blockquote><p>讓我們看一下代碼：</p><p><a href="inherit-create.js">inherit-create.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// Animal 原型</span><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">talk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabit</span>(<span class="hljs-params">name, color</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Rabit</span>;<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__ === Rabit.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__.__proto__ === Animal.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）執行這段代碼吧</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-create.png" alt="inherit-create"></p><p>我們可以看到，原型鏈被完整的串接起來，從 <code>rabit</code> 到 兔子原型（<code>Rabit.prototype</code>）再到 動物原型（<code>Animal.prototype</code>）和 物件原型（<code>Object.prototype</code>）</p><p>這裡要注意的是，和前面提到的『實例』和『取代』方法一樣，要記得指定子物件原型的建構式（<code>Rabit.prototype.constructor = Rabit</code>），如果不指定的話，將會指向父物件原型的建構式（也就是 <code>Animal()</code>）</p><p>同樣的，讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-create-mind.png" alt="inherit-create-mind.png"></p><p>從心理模型中我們可以看到，兔子原型（<code>Rabit.prototype</code>）連接著 動物原型（<code>Animal.prototype</code>），完成『原型鏈的串接』</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a><code>class</code></h3><p>使用內建語法 <code>class</code> 和 <code>extends</code> 來『繼承』『物件』</p><p><a href="inherit-class.js">inherit-class.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Animal 建構式（父物件）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">talk</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, my nmae is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Rabit 建構式（子物件）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rabit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, color</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cololr</span> = color;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 創建 Rabit 實例</span><br><span class="hljs-keyword">const</span> rabit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabit</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit :&gt;&gt; &#x27;</span>, rabit);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__ === Rabit.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Rabit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rabit.__proto__.__proto__ === Animal.prototype :&gt;&gt; &#x27;</span>, rabit.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>讓我們在瀏覽器（Safari 15.1）中執行看看</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-class.png" alt="inherit-class"></p><p>可以看到使用 <code>extends</code> 繼承的方式，和『連結』與『創建』兩種方法一樣，有著相同的原型鏈結構</p><blockquote><p>注意，<code>class</code> 中宣告的函式是屬於原型的</p></blockquote><p>讓我們將這樣的方式轉換成『心理模型』：</p><p><img src="/2022/04/21/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8B%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/inherit-class-mind.png" alt="inherit-class-mind.png"></p><p>從心理模型中我們可以看到，兔子原型（<code>Rabit.prototype</code>）連接著 動物原型（<code>Animal.prototype</code>），完成『原型鏈的串接』</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>至此，我們講述完了 6 種原型繼承方式『建構式、實例、取代、連結、創建、class』</p><p>除了第一種『建構式』方式無法真正達成原型鏈的串接外，剩下 5 種都可以完成原型鏈的串連</p><p>在這 5 種中，其中 3 種（連結、創建、class）所建構出的原型鏈結構又相同</p><p>而這 3 種所建構出的原型鏈，也是自己覺得最貼近『原型繼承』這個概念的方法</p><p>最後，做一個『原型繼承』重點整理</p><ul><li><strong>建構式</strong><br>  子物件建構式中，呼叫父物件建構式（可以取得父物件建構式定義的屬性、方法，但不能取得原型）</li><li><strong>實例</strong><br>  以父物件 創建的實例，作為（取代）子物件的原型（<code>Rabit.prototype = new Animal()</code>）</li><li><strong>取代</strong><br>  以父物件 的原型，作為（取代）子物件的原型（<code>Rabit.prototype = Animal.prototype</code>）</li><li><strong>連結</strong><br>  將子物件 的原型，和 父物件 的原型 連結（<code>Object.setPrototypeOf(Rabit.prototype, Animal.prototype)</code>）</li><li><strong>創建</strong><br>  創建一個以 父物件 的原型 為原型 的 物件，作為（取代）子物件的原型（<code>Rabit.prototype = Object.create(Animal.prototype)</code>）</li><li><strong>class</strong><br>  使用 <code>extends</code> 關鍵字繼承 父物件</li></ul><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Classes - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf() - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create() - JavaScript | MDN</a></li><li><a href="https://javascript.info/classes">Classes | JavaScript.info</a><br><a href="https://hijiangtao.github.io/2018/06/17/Shapes-ICs/">JavaScript 引擎基礎：Shapes 和 InlineCaches</a><br><a href="https://hijiangtao.github.io/2018/08/21/Prototypes/">JavaScript 引擎基礎：原型優化</a></li><li><a href="https://mathiasbynens.be/notes/prototypes">how modern JavaScript engines optimize property accesses</a></li><li><a href="https://www.toptal.com/javascript/javascript-prototypes-scopes-and-performance-what-you-need-to-know">JavaScript Prototype Chains, Scope Chains and Performance: What You Need To Know</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, class, prototye</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 世界起源上（原型鏈）</title>
    <link href="/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/"/>
    <url>/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<!-- // FIXME: JavaScript 世界起源上下，文章連結加上 --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 的原型鏈（prototype chain）對於第一次接觸且已經熟悉面向對象編程（object-oriented programming，OOP）的新手，可能會感到困惑。</p><p>JavaScript 的設計者 Brendan Erich 選擇以一種截然不同的方式，來設計 OOP 中的『繼承 inheritance』，這樣選擇的初衷究竟是什麼？推薦可以看下 <a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">JavaScript 繼承機制設計思想｜阮一峰的網路日誌</a></p><blockquote><p>JavaScript 以下簡稱 JS</p></blockquote><p>那麼，究竟差別在哪？</p><p>讓我們從 <a href="">JavaScript 世界起源上</a><a href="">、下</a> 一步步藉著代碼、和想像力來認識『JS 中的原型鏈（prototype chain）』</p><p>在本章節進入『原型鏈』的部分前，有些前置知識我們需要先建立起來，所以我們會先帶你了解：</p><ul><li><a href="#OOP-%E5%B8%B8%E8%A6%8B%E7%9A%84%E8%A1%93%E8%AA%9E%E4%BB%8B%E7%B4%B9%EF%BC%9Aclass%E3%80%81instance%E3%80%81object-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E6%8A%BD%E8%B1%A1%EF%BC%9F%E5%85%B7%E9%AB%94%EF%BC%9F">OOP 常見的術語介紹：class、instance、object 是什麼？抽象？具體？</a></li><li><a href="#%E4%BB%80%E9%BA%BC%E6%98%AF-Function%EF%BC%9F%E4%BB%A5%E5%8F%8A-call-%E3%80%81apply-%E3%80%81bind-%E5%92%8C-this-%E7%9A%84%E9%97%9C%E4%BF%82">什麼是 Function？ 以及 call()、apply()、bind() 和 this 的關係</a></li><li><a href="#%E5%BB%BA%E6%A7%8B%E5%BC%8F-Constructor-%E5%92%8C-new-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E9%97%9C%E4%BF%82">建構式 Constructor 和 new 運算子的關係</a></li></ul><p>有了上述的前置知識，我們就可以進入 JS 原型鏈的世界了！</p><p>本章的原型鏈你將會了解到：</p><ul><li><a href="#%E6%B7%B1%E5%85%A5%E5%8E%9F%E5%9E%8B%E9%8F%88-Prototype-Chain">深入原型鏈 Prototype Chain</a></li><li><a href="#%E8%A7%80%E5%BF%B5%E7%B8%BD%E7%B5%90">觀念總結</a></li></ul><h2 id="OOP-常見的術語介紹：class、instance、object-是什麼？抽象？具體？"><a href="#OOP-常見的術語介紹：class、instance、object-是什麼？抽象？具體？" class="headerlink" title="OOP 常見的術語介紹：class、instance、object 是什麼？抽象？具體？"></a>OOP 常見的術語介紹：class、instance、object 是什麼？抽象？具體？</h2><p>在 面向對象編程（OOP）我們常聽到幾個名詞</p><ul><li>類（class）</li><li>實例（instance）</li><li>對象（object）</li></ul><p>讓我們從『是否抽象』的角度來切入理解吧</p><p>一件事物是否抽象，我們可以從他是否看得到、聽得到、拿得到、實際存在…等，來判斷；如果這個事物只是『概念性、不特定性』的，那麼我們說他是抽象。</p><blockquote><p>在判斷一件事物是否抽象，似乎不是這麼好思考，所以我們更常傾向於判斷它『是否具體』，就如上面列出的條件：『是不是看得到、實際存在…等』</p></blockquote><p>在 OOP 文章中，時常看見『動物』被拿來當作範例，我想大概是因為『生物分類法（界門綱目科屬種）』就是一種說明『概念性、抽象』最直覺的例子。</p><p>舉例來說：當我們說『人屬 智人種』我們大概猜得到，就是在講口語的『人類』的意思，但這個人類指的是『你』還是『我』還是誰？</p><p>的確，並沒有特定是『誰』，只要符合生物分類法中的描述，都可以叫做『人類』；而『我』或是『你』則是具體的，我們都實際存在，並且具有人類的特徵。</p><blockquote><p>OOP 是一種試圖描述真實世界樣子的程序設計思想</p></blockquote><p>接著，讓我們套用 OOP 的名詞來換句話說吧</p><ul><li>類（class)：人類</li><li>實例（instance）：我 or 你 是『人類』這一抽象概念的實際例子</li><li>對象（object）：我 or 你</li></ul><p>所以當我們在 OOP 中看見這幾個名詞我們要知道：</p><ul><li>類（class）是『抽象』的</li><li>實例（instance）是用來形容 類 和 對象 之間的『關係』</li><li>對象（object）是『具體』的</li></ul><blockquote><p>在 OOP 中我們設計『類』，來創建出不同情境下需要的『對象』（使用 new 運算子）</p></blockquote><h2 id="什麼是-Function？以及-call-、apply-、bind-和-this-的關係"><a href="#什麼是-Function？以及-call-、apply-、bind-和-this-的關係" class="headerlink" title="什麼是 Function？以及 call()、apply()、bind() 和 this 的關係"></a>什麼是 Function？以及 call()、apply()、bind() 和 this 的關係</h2><p>在學習 JS 的過程中，我們常會聽見這麼一句話『JavaScript 中的所有的數據都是對象（object）』，要如何理解這句話呢？</p><p>在這裡我們先將問題縮小，讓我們專注在『函式 function 是對象（object）嗎？』這件事情上。</p><p>首先，答案是肯定的</p><p>在查找 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">MDN 文件</a>中，我們可以看見開頭第一句話是這麼說的</p><blockquote><p>Every JavaScript function is actually a <code>Function</code> object.</p></blockquote><h3 id="JS-中的函式也是對象（object）？"><a href="#JS-中的函式也是對象（object）？" class="headerlink" title="JS 中的函式也是對象（object）？"></a>JS 中的函式也是對象（object）？</h3><p>那麼我們要如何理解、驗證這件事情呢？</p><p>在開始理解、驗證前，我們思考下 OOP 中的 類（class）、實例（instance）、對象（object）在 JS 的世界中扮演著什麼樣的角色？</p><p>引用整理至 <a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">JavaScript 繼承機制設計思想｜阮一峰的網路日誌</a> 的內容：</p><p>『1994 年當時，是 OOP 最興盛的時期，而 JS 的設計者 Brendan Eich 也因此受到了影響，JS 中的所有數據類型都是對象（object）…但是 Brendan Eich 不打算將 JS 設計成一種完整的面向對象編程語言，因此類 class 的概念並未引入 JS 中』</p><p>從這樣的緣由，我們可以了解到類 class 的概念並不存在於 JS 中，自然而然『繼承 inheritance』也不存在。</p><p>然而，Brendan Eich 面對 JS 中眾多的對象，思考著必須要存在一種機制能夠將之關聯起來，所以最後取而代之的是『原型繼承 prototypal inheritance』的概念。</p><blockquote><p>記住！在 JS 中我們談論的繼承，並非 OOP 中的『繼承 inheritance』而是 JS 自己獨有的『原型繼承 prototypal inheritance』</p></blockquote><p>因此，我們在 OOP 的觀念在 JS 中變成這樣</p><ul><li>類（class）：在 JS 中，不存在類的概念，只是原型鏈的語法糖</li><li>實例（instance）：在 JS 中，我們談論 A 對象是否是 B 對象的實例時，所指的是 B 對象是否存在於 A 對象的原型鏈上方</li><li>對象（object）：我們所認知的物件，具體、可以有屬性、方法</li></ul><blockquote><p>語法糖：指的是對語言功能本身沒有任何影響，但是這樣的語法可以更容易被使用，讓程序編寫可以更簡潔，擁有更高的可讀性</p></blockquote><h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><p>那麼，回到正題『函式 function 是對象（object）嗎？』，這件事要如何驗證呢？</p><p>讓我們使用 <code>typeof</code> 和 <code>instanceof</code> 這兩個 JS 語法來驗證這件事情吧</p><ul><li><code>typeof</code> 可以知道後方連接的對象（object）是什麼型別（type）</li><li><code>instanceof</code> 可以知道一個對象是否是另一個對象的實例（也就是是否存在於原型鏈中）</li></ul><blockquote><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Data_structures">ECMAScript 標準中定義了 8 種型別</a>，7 類原始型別 primitive (Boolean、Null、Undefined、Number、BigInt、String、Symbol)和 1 類物件型別 object（object、function、array）</p></blockquote><p><a href="function.js">function.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 創建一個繼承 Function 物件的函式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">helloWorld</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 驗證型別</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;typeof helloWorld :&gt;&gt; &#x27;</span>, <span class="hljs-keyword">typeof</span> helloWorld); <span class="hljs-comment">// function</span><br><span class="hljs-comment">// 驗證 helloWorld 是否繼承自 Function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;helloWorld instanceof Function :&gt;&gt; &#x27;</span>, helloWorld <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 驗證 Function 是否繼承自 Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Function instanceof Object :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 驗證 helloWorld 是否繼承 Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;helloWorld instanceof Object :&gt;&gt; &#x27;</span>, helloWorld <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>從上方的驗證，我們可以知道『函式 function 的確是對象（object)』。</p><p>另外，我們似乎也看見了一點原型鏈的輪廓，<code>helloWorld</code> 上方接著 <code>Function</code>，<code>Function</code> 上方接著 <code>Object</code>。</p><p>讓我們將這樣的輪廓記下來，待後續一步步將原型鏈這塊拼圖一片片拼湊完成。</p><blockquote><p>記住！這裡的輪廓並非全貌，然而作為一個旅程的開端是不錯的地圖</p></blockquote><h3 id="Function-原型方法：-call-、apply-、bind-和-this"><a href="#Function-原型方法：-call-、apply-、bind-和-this" class="headerlink" title="Function 原型方法： call()、apply()、bind() 和 this"></a><code>Function</code> 原型方法： <code>call()</code>、<code>apply()</code>、<code>bind()</code> 和 <code>this</code></h3><p>現在，我們理解 JS 中『函式也是物件』這件事了，接著讓我們來看一下函式作為一個『物件』的幾個和 <code>this</code> 有關的重要方法（method）。</p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">Function | MDN 文件</a></p></blockquote><p><code>this</code> 在其他 OOP 語言中（ex. C++）並不難，就是一個指向實例本身自己的指標，至始至終不會改變；然而，在 JS 中 <code>this</code> 卻不是固定指向物件本身。</p><p>讓我們先記住一個 <code>this</code> 的重要觀念</p><blockquote><p>在大部分的情況下，當談論到『物件』時，<code>this</code> 才具有意義；想知道一個函式的 <code>this</code> 指向哪個物件，就思考是誰呼叫（invoke）了這個函式（推薦閱讀 <a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂｜Huli</a>）</p></blockquote><p>讓我來做些實驗（以下實驗均在『嚴格模式』環境下執行；ES6 後默認使用嚴格模式）</p><p><a href="this.js">this.js</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 定義一個全域變數 name（觀察待會函式的呼叫會不會打印出這個變數）<br>const name = <span class="hljs-string">&quot;Liz&quot;</span>;<br><br><span class="hljs-regexp">//</span> 定義一個物件<br>const child = &#123;<br>    <span class="hljs-regexp">//</span> 定義一個區域變數 name（觀察待會函式的呼叫會不會打印出這個變數）<br>    name: <span class="hljs-string">&#x27;Chris&#x27;</span>,<br>    hi: <span class="hljs-keyword">function</span> () &#123;<br>        console.log(<span class="hljs-string">&#x27;my name is :&gt;&gt;&#x27;</span>, this.name);<br>    &#125;<br>&#125;;<br><br><span class="hljs-regexp">//</span> 讓我們將 child 中 hi 函式賦值給 aliasHi 這個址參器，製造一個分身<br>const aliasHi = child.hi;<br><br><span class="hljs-regexp">//</span> 觀察 aliasHi 和 child.hi 兩個函式的輸出<br>child.hi(); <span class="hljs-regexp">//</span> Chris<br>aliasHi(); <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><p>回顧一下 <code>this</code> 的觀念『誰（物件）呼叫函式，<code>this</code> 就指向誰』</p><p>因此，上面的實驗結果我們可以這樣理解</p><ul><li><code>child.hi()</code>：hi 這個函式由 child 這個物件呼叫，<code>this</code> 指向 child，所以 <code>this.name</code> 打印出來為 Chris</li><li><code>aliasHi()</code>：aliasHi 沒有由任何物件呼叫，<code>this</code> 指向 undefined，所以 <code>this.name</code> 自然也是 undefined</li></ul><p>讓我們再加深一下 <code>this</code> 的觀念</p><blockquote><p>JS 中的 <code>this</code> 是由運行環境（runtime）中誰（object）去調用（invoke）這個函式決定的</p></blockquote><p>至此，我們來看下，下方這三個 Function 原型方法和 <code>this</code> 有什麼關係吧</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Function.prototype.call()</a>：將 Function 內部的 <code>this</code> 指向 call 傳入的物件參數</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">Function.prototype.apply()</a>：將 Function 內部 <code>this</code> 指向 apply 傳入的物件參數</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function.prototype.bind()</a>：將 Function 內部 <code>this</code> 永遠綁定 bind 傳入的物件參數</li></ul><p>這 3 個原型方法中基本上接收的參數大致相同</p><ul><li>第 1 個參數：接受一個 <code>this</code>，這個 <code>this</code> 會影響 Function 內 <code>this</code> 所指向的物件是誰</li><li>第 2 個參數：<code>apply</code> 接受一個陣列，<code>call</code> 和 <code>bind</code> 則是從此開始接受不特定數量（N個）參數輸入</li></ul><p>讓我們來編寫代碼驗證</p><p><a href="call-apply-bind.js">call-apply-bind.js</a></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 編寫一個函式，給 childA 和 childB 兩物件共用</span><br>function hi(arg1 = <span class="hljs-number">1</span>, arg2 = <span class="hljs-number">2</span>, arg3 = <span class="hljs-number">3</span>) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;this.name :&gt;&gt; &#x27;</span>, this.<span class="hljs-built_in">name</span>);<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;arg1 :&gt;&gt; &#x27;</span>, arg1);<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;arg2 :&gt;&gt; &#x27;</span>, arg2);<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;arg3 :&gt;&gt; &#x27;</span>, arg3);<br>&#125;<br><br><span class="hljs-comment">// childA 物件</span><br>const childA = &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Chris&#x27;</span>,<br><br>    <span class="hljs-built_in">say</span>: hi,<br>&#125;;<br><br><span class="hljs-comment">// childB 物件</span><br>const childB = &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;Liz&#x27;</span>,<br><br>    <span class="hljs-built_in">say</span>: hi,<br>&#125;;<br><br><span class="hljs-comment">// 開始各種呼叫</span><br>childA.<span class="hljs-built_in">say</span>(); <span class="hljs-comment">// Chris, 1, 2, 3</span><br><br>childA.<span class="hljs-built_in">say</span>.<span class="hljs-built_in">call</span>(childB); <span class="hljs-comment">// Liz, 1, 2, 3</span><br><br>childA.<span class="hljs-built_in">say</span>.<span class="hljs-built_in">call</span>(childB, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// Liz, 4, 5, 6</span><br><br>childA.<span class="hljs-built_in">say</span>.<span class="hljs-built_in">apply</span>(childB, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]); <span class="hljs-comment">// Liz, 4, 5, 6</span><br><br>const aliasChildB = childA.<span class="hljs-built_in">say</span>.bind(childB);<br><br>aliasChildB(); <span class="hljs-comment">// Liz, 4, 5, 6</span><br><br>aliasChildB(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// Liz, 7, 8, 9</span><br><br>const aliasChildB2 = childA.<span class="hljs-built_in">say</span>.bind(childB, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>);<br><br>aliasChildB2(); <span class="hljs-comment">// Liz, 10, 11, 12</span><br><br>aliasChildB2(<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>); <span class="hljs-comment">// Liz, 10, 11, 12</span><br></code></pre></td></tr></table></figure><p>上面可以觀察到 2 個現象</p><ul><li>明明是 <code>childA</code> 呼叫 <code>say</code> 函式，在使用 <code>call</code> 和 <code>apply</code> 指定傳入 <code>childB</code> 後，函式內 <code>this</code> 改成指向 <code>childB</code>（這就是 <code>call</code> 和 <code>apply</code> 在做的事情）</li><li><code>bind</code> 呼叫時，連同引數輸入的話，引數（argument）會和 <code>this</code> 一樣有綁定效果</li></ul><blockquote><p>記住！自己思考、動手做一遍</p></blockquote><h2 id="建構式-Constructor-和-new-運算子的關係"><a href="#建構式-Constructor-和-new-運算子的關係" class="headerlink" title="建構式 Constructor 和 new 運算子的關係"></a>建構式 Constructor 和 new 運算子的關係</h2><p>有了前面的打底，我們接著只要理解『 JS 中物件是如何被創建出來的』後，就可以進入『原型鏈』的世界了</p><p>讓我們快速複習下『原型鏈』的歷史由來</p><blockquote><p>『原型鏈』是來自於 JS 設計者為了解決物件（object）間關聯問題而設計的一種機制『原型繼承 Prototypal Inheritance』的產物</p></blockquote><p>在 JS 的世界中，雖然沒有 OOP 中 類（class）的概念，然而在創建一個新物件時，倒是有幾分相似；JS 的設計者 Brendan Erich，模仿了 OOP 語言中，使用 <code>new</code> 運算子創建物件時，會調用建構式 <code>constructor</code> 這樣的性質</p><blockquote><p>補充：建構式 constructor 在 JS 中，本質上就是一般的 function，為了區別是用作創建物件，所以習慣以大寫字母開頭作為識別；那麼真正做事的是誰？其實是 <code>new</code> 運算子，讓我們看下文件是如何描述 <code>new</code> 運算子做了哪些事情</p></blockquote><p>讓我們看下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator｜MDN</a> 文件中，如何描述『物件被創建的過程』</p><blockquote><p>The <code>new</code> keyword does the following things:</p><ol><li>Creates a blank, plain JavaScript object.</li><li>Adds a property to the new object (<code>__proto__</code>) that links to the constructor function’s prototype object</li></ol><blockquote><p>Note: Properties&#x2F;objects added to the construction function prototype are therefore accessible to all instances created from the constructor function (using new).</p></blockquote><ol start="3"><li>Binds the newly created object instance as the <code>this</code> context (i.e. all references to <code>this</code> in the constructor function now refer to the object created in the first step).</li><li>Returns <code>this</code> if the function doesn’t return an object.</li></ol></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;Liz&#x27;</span>;<br>    <span class="hljs-keyword">this</span>.age = <span class="hljs-number">18</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> childA = <span class="hljs-keyword">new</span> Child();<br></code></pre></td></tr></table></figure><p>當我們如上面代碼，使用 <code>new</code> 運算子創建物件時，有幾件事情 JS 會在背後執行</p><ol><li>創建一個『空物件』，就像這樣 <code>&#123;&#125;</code></li><li>為這個空物件增加一個屬性叫做 <code>__proto__</code>，裡面存的是『建構式』的『原型』（意思就是：<code>childA.__proto__ = Child.prototype</code>）</li><li>將『建構式』中的 <code>this</code> 指向這個『新物件』，並執行建構式</li><li>將 <code>this</code> 作為『建構式』的返回值返回</li></ol><blockquote><p><code>__proto__</code> 中會存儲一個物件的原型鏈中上方是誰（object）；意思就是他是『繼承』哪一個『原型』。</p></blockquote><p>至此，是一個不好理解的過程，讓我們先將理解放一旁吧，來動手編寫些代碼</p><blockquote><p>深入閱讀系列文章 <a href="https://javascript.info/prototypes">Prototypes, Inheritance | JavaScript.info</a></p></blockquote><h3 id="驗證-1"><a href="#驗證-1" class="headerlink" title="驗證"></a>驗證</h3><p><a href="constructor.js">constructor.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 宣告一個建構式（constructor）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 增加一個原型方法（所有使用 new 運算子和 Child 建構是創建的新物件都會繼承這個方法）</span><br><span class="hljs-comment">// 說是『繼承』，其實只是在原型鏈上方都會連結到這個方法</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">selfIntro</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My name is :&gt;&gt;&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My age is :&gt;&gt;&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-comment">// 創建一個繼承 Child 原型的物件</span><br><span class="hljs-keyword">const</span> childLiz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Liz&#x27;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;------------------------------&#x27;</span>);<br><br><span class="hljs-comment">// 檢查是否有繼承原型方法</span><br>childLiz.<span class="hljs-title function_">selfIntro</span>();<br><br><span class="hljs-comment">// 用代號表示新物件，和沿著原型鏈往上方尋找</span><br><span class="hljs-keyword">const</span> A = childLiz;<br><span class="hljs-keyword">const</span> B = A.<span class="hljs-property">__proto__</span>; <span class="hljs-comment">// 等同 Object.getPrototypeOf(A);</span><br><span class="hljs-keyword">const</span> C = B.<span class="hljs-property">__proto__</span>; <span class="hljs-comment">// 等同 Object.getPrototypeOf(B);</span><br><span class="hljs-keyword">const</span> D = C.<span class="hljs-property">__proto__</span>; <span class="hljs-comment">// 等同 Object.getPrototypeOf(C);</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;------------------------------&#x27;</span>);<br><br><span class="hljs-comment">// 原型鏈的組成</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A :&gt;&gt; &#x27;</span>, A);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B :&gt;&gt; &#x27;</span>, B);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C :&gt;&gt; &#x27;</span>, C);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;D :&gt;&gt; &#x27;</span>, D);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;------------------------------&#x27;</span>);<br><br><span class="hljs-comment">// 各個原型分別代表誰（object）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A === childLiz :&gt;&gt; &#x27;</span>, A === childLiz);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B === Child.prototype :&gt;&gt; &#x27;</span>, B === <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C === Object.prototype :&gt;&gt; &#x27;</span>, C === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;D === null :&gt;&gt; &#x27;</span>, D === <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>從上方的代碼當中，我們可以很清楚看到原型鏈一路是如何被串起來，直到 <code>null</code></p><ul><li>childLiz -&gt; Child.protoype -&gt; Object.prototype -&gt; null</li></ul><blockquote><p>原型鏈的盡頭指向 <code>null</code></p></blockquote><p>當我們用 <code>.</code> 運算子訪問一個物件的屬性或方法，JS 就會一路沿著原型鏈中尋找，直到『找到』或是『到達 null』</p><p>上面的範例，就像一個速成班的版本，先建立一個單純、正確的觀念；為什麼這樣說呢？</p><p>因為完整的原型鏈的關係圖，實際上沒有這麼單純；然而，我覺得對於一開始建立觀念來說，上方才是真正重要的事情。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>後續，我們將在更深入的談到完整的原型鏈關係圖；那麼現在讓我們再次加深本章的觀念</p><ul><li>當我們要尋找一個物件（object）是繼承自哪個原型時，我們可以訪問 <code>__proto__</code> 或是將物件放進 <code>Object.getPrototypeOf()</code></li><li>『建構式 Constructor』就是一個以大寫命名開頭的一般函式，真正在為原型鏈貢獻的人是 <code>new</code> 運算子</li><li>JS 在設計上，將原型存儲在『建構式的 <code>prototype</code> 屬性中』，當使用 <code>new</code> 創建物件時，會將新物件的原型鏈與之串連起來</li><li>想要理解『原型 prototype』是什麼，就思考 JS 的設計者設計它的原因：『用來關聯物件（共享數據）』</li></ul><p>從原型鏈的種種觀念中，我們可以這樣理解幾件事情</p><p>-『想要共享的數據就放在原型 prototype 中』，因此『方法（函式）』適合放在 prototype 中，實際上 <code>class</code> 語法糖也是這麼處理的<br>-『物件（object）獨有的數據就交由建構式（constructor）生成』，因此『屬性（資料）』適合交由建構式生成；換句話說，『函式』不適合放在建構式當中，會使得每個物件都再次分配記憶體空間 </p><h2 id="深入原型鏈-Prototype-Chain"><a href="#深入原型鏈-Prototype-Chain" class="headerlink" title="深入原型鏈 Prototype Chain"></a>深入原型鏈 Prototype Chain</h2><p>原型鏈的歷史、基礎觀念大致講述完畢，是時候了解下完整的原型鏈關係。</p><p><img src="/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/object-layout.png"></p><blockquote><p>引用自 StackOverflow</p></blockquote><p>上圖，我想對於新手來說不是這麼好理解的一張圖，至少對於當時的自己是如此；然而，它的確清楚、完整的表達了原型鏈中物件之間的關係。</p><p>那麼，究竟要從什麼樣的角度才能更好地理解、吸收呢？先讓我們看過一遍，後面再試著整理出容易理解的心理模型。</p><p>首先，整張圖有 3 個部分</p><ul><li>左：此區表示的是被建構出來的『物件實例 instance』（也就是對 建構式 使用 <code>new</code> 運算子創建出來的物件）</li><li>中：此區表示的是『建構式 constructor』（是函式，也是物件）</li><li>右：此區表示的是『原型 prototype』（儲存在建構式物件當中的原型）</li></ul><p>區域理解後，接著了解圖中 2 種關係線</p><ul><li><code>__proto__</code>：表示物件在原型鏈中指向的原型是誰</li><li><code>constructor</code>：表示物件本身是由哪一個『建構式』所創造出來</li></ul><blockquote><p>圖中 <code>Foo</code> 表示我們自定義的建構式，<code>Object</code> 和 <code>Function</code> 則都是 JS 內建的</p></blockquote><p>至此，可以停下來自己試著理解下；接下來讓我們將上圖轉換成更容易理解的心理模型</p><h3 id="建構心理模型"><a href="#建構心理模型" class="headerlink" title="建構心理模型"></a>建構心理模型</h3><p><img src="/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/regular.png"></p><p>原本的原型鏈關係圖，完整但不容易理解，因此我們做了幾項調整</p><ul><li>增加方向性，由上至下，由左至右，將原型鏈層級關係表達清楚</li><li>將原型、建構式以集合關係表達</li></ul><p>那麼，讓我們開始理解下心理模型</p><ul><li>原型的部分使用紅色表達</li><li>我們知道建構式 constructor 是函式（藍色）也是物件（綠色）；作為一個物件，擁有 prototype 屬性來存儲原型；而 prototype 屬性中擁有 constructor 屬性指向作為建構式的自己</li><li>灰色、紫色區塊則是，當我們對建構式使用 <code>new</code> 運算子建構實例的過程中，會將這些實例和自己的原型做一個連結</li></ul><p>至此，我們的原型鏈心理模型就建構完成</p><h3 id="有人說-Function-和-Object-有著不可告人的複雜關係？是怎麼回事？"><a href="#有人說-Function-和-Object-有著不可告人的複雜關係？是怎麼回事？" class="headerlink" title="有人說 Function 和 Object 有著不可告人的複雜關係？是怎麼回事？"></a>有人說 Function 和 Object 有著不可告人的複雜關係？是怎麼回事？</h3><p>上述的心理模型基本上就是原型鏈的大概了，然而我們回過頭觀察完整的原型鏈關係圖，卻有更複雜的關係</p><ul><li><code>Object</code> 本身的原型是 <code>Function.prototype</code></li><li><code>Function</code> 本身的原型也是 <code>Function.prototype</code></li></ul><p>為什麼…？奇怪？也許上面這邊感受不到太直覺怪異之處，讓我們看一下下面的代碼</p><p><a href="prototype.js">prototype.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object instanceof Function :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Function instanceof Object :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><ul><li><code>Object</code> 是 <code>Function</code> 的實例</li><li><code>Function</code> 是 <code>Object</code> 的實例</li></ul><p>這…是什麼情況？雞生蛋，蛋生雞；為什麼有這樣的現象？</p><p>造成這樣現象的原因，其實就是我們一直提到的『JS 世界中所有數據都是物件』這件事，因而衍生出『函式也是物件』這樣的情況</p><p>所以，在我們看來是雞生蛋，蛋生雞，但是情況卻有些微不同之處，讓我們仔細地深入了解下吧！</p><p>首先，我們思考下這裡的 <code>Object</code> 和 <code>Function</code> 是什麼？</p><p>是『物件 object』這點應該毋庸置疑，然而其實也是『函式 function』，在這也可以說是『建構式 constructor』</p><p>那麼，作為一個『建構式』是『函式也是物件』，自然而然繼承了『物件的原型』和『函式的原型』也不奇怪吧！</p><blockquote><p>JS 中的原型繼承，一次只能繼承一個物件；從心裡模型來看，所謂的『函式』繼承『物件原型』和『函式原型』，實際上的原型鏈關係其實是『函式實例 繼承函式原型』，『函式原型 繼承 物件原型』</p></blockquote><p>所以，讓我們多加幾行代碼</p><p><a href="prototype.js">prototype.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 作為一個 Object() 建構式，繼承了『物件原型』和『函式原型』</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object instanceof Object :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object instanceof Function :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 作為一個 Function() 建構式，繼承了『物件原型』和『函式原型』</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Function instanceof Object :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Function instanceof Function :&gt;&gt; &#x27;</span>, <span class="hljs-title class_">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>至此，當我們拋開 <code>instanceof</code> 前方混淆我們的 <code>Object</code> 和 <code>Function</code>，從『建構式 constructor』的角度切入理解，我們就可以了解為什麼會有看似『雞生蛋，蛋生雞』的現象</p><blockquote><p>從上面這樣的觀念，我們不難想像，所有的『建構式』或更直接點『函式』都擁有『物件 <code>Object.prototype</code>、函式 <code>Function.prototype</code>』兩個原型</p></blockquote><p>從建構心裡模型的角度來看，直接拉關聯線指向彼此似乎不是一個好的方式，所以我們將 <code>Function.prototype</code> 做一個替身單獨拉出來，讓所有原型鏈關係圖中的物件可以更清楚、容易的指向它</p><p>最後，我們的心裡模型圖變成這樣</p><p><img src="/2022/04/16/JavaScript-%E4%B8%96%E7%95%8C%E8%B5%B7%E6%BA%90%E4%B8%8A%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%8F%88%EF%BC%89/full.png"></p><h2 id="觀念總結"><a href="#觀念總結" class="headerlink" title="觀念總結"></a>觀念總結</h2><ul><li>『函式』在 JS 中既是『函式 function』也是『對象 object』；所以函式（函式原型的實例）在『原型鏈』當中同時擁有 『函式原型 <code>Function.prototype</code>』和『物件原型 <code>Object.prototype</code>』</li><li>『建構式』本質上就是『函式』，創建對象的工作其實由 <code>new</code> 運算子完成</li><li><code>new</code> 運算子在創建對象過程中做的 4 件事『建立空物件、連結原型鏈、<code>this</code> 指向、和返回』</li><li>想知道一個函式中 <code>this</code> 指向誰，就要看在執行階段時，是誰（object）呼叫了這個函式</li><li>『函式原型 <code>Function.prototype</code>』的 3 個方法『<code>call</code>、<code>apply</code>、<code>bind</code>』可以用來控制『函式內 <code>this</code> 的指向』</li><li>『原型鏈』來自『原型繼承』這個機制的產物，而『原型繼承』則是被設計來將『物件』之間關聯起來（共享數據）</li><li>JS 中的『原型繼承』，一個物件只能繼承一個物件</li><li>JS 的世界中沒有『類 class』和『繼承 inheritance』的概念，取而代之的是『物件 object』和『原型繼承 prototypal inheritance』</li></ul><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator - JavaScript | MDN</a></li><li><a href="https://blog.huli.tw/2021/09/29/prototype-pollution/">基於 JS 原型鏈的攻擊手法：Prototype Pollution</a></li><li><a href="https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/">該來理解 JavaScript 的原型鍊了</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">JavaScript 繼承機制的設計思想</a></li><li><a href="https://javascript.info/prototypes">Prototypes | JavaScript.info</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, prototype, this, function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 二元樹：前序、中序、後序、層序演算法（上）</title>
    <link href="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章依照自己的理解和話，整理、延伸自<a href="http://alrightchiu.github.io/SecondRound/pages/about.html">Chiu CC 部落格</a> 有關於樹的一系列以 C++ 實作的文章重點。</p><p>接下來簡單介紹下二元樹 Binary Tree，以及使用 JavaScript 實作出二元樹 4 種尋訪（前、中、後、層序），實作的過程會紀錄尋訪規則、資料結構、演算法設計，一直到建構代碼。</p><h2 id="二元樹『介紹』"><a href="#二元樹『介紹』" class="headerlink" title="二元樹『介紹』"></a>二元樹『介紹』</h2><p>所謂的二元樹 Binary Tree 即是除了具有原本樹 Tree 的性質外，再加上每個節點限制至多兩個子樹的特性（degree 為 2 的限制）。</p><blockquote><p>一般以左子樹 left child 和 右子樹 right child 來稱呼。</p></blockquote><h3 id="Full-Binary-Tree"><a href="#Full-Binary-Tree" class="headerlink" title="Full Binary Tree"></a>Full Binary Tree</h3><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/full-binary-tree.png"></p><p>當一個二元樹，符合以下 2 個條件時，即可稱為 Full Binary Tree</p><ul><li>所有 leaf node 都具有相同的 level</li><li>除 leaf node 外的 node 都具有 2 個 child</li></ul><p>衍生特性</p><ul><li>N level 的 Full Binary Tree，共有 2^N - 1 個 node</li><li>第 N 個 node 的 left child 索引值為 2N，right child 索引值為 2N + 1</li><li>第 N 個 node 的 parent 索引值為 N &#x2F; 2 取整數</li></ul><h3 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a>Complete Binary Tree</h3><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/complete-binary-tree.png"></p><p>若一個二元樹 node 排列按照 Full Binary Tree 次序（由上至下，由左至右），則稱此數為 Complete Binary Tree。</p><h2 id="二元樹『尋訪』"><a href="#二元樹『尋訪』" class="headerlink" title="二元樹『尋訪』"></a>二元樹『尋訪』</h2><p>『尋訪（Traversal）』的意思就是『從一個起始點開始，往所有與該點相連的地方移動』。</p><ul><li>層序的規則如上面 Complete Binary Tree、Full Binary Tree 所表示，每層依序由左至右</li><li>前、中、後序規則如下圖</li></ul><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/order.png"></p><h3 id="符號定義"><a href="#符號定義" class="headerlink" title="符號定義"></a>符號定義</h3><ul><li>V：對當前節點進行『訪問』</li><li>L：移動至當前節點的『左子樹』</li><li>R：移動到當前節點的『右子樹』</li><li>P：移動到當前節點的『父節點』</li><li>()：用來刮住上述符號，表示移動 or 訪問失敗</li></ul><h3 id="觀念建立"><a href="#觀念建立" class="headerlink" title="觀念建立"></a>觀念建立</h3><p>前、中、後序的尋訪規則分別為 VLR、LVR、LRV</p><ul><li>前序：訪問 -&gt; 前往左子樹 -&gt; 前往右子樹</li><li>中序：前往左子樹 -&gt; 訪問 -&gt; 前往右子樹</li><li>後序：前往左子樹 -&gt; 前往右子樹 -&gt; 訪問</li></ul><p>尋訪規則所表達的是『優先程度』。以中序規則來說，並不是前往左子樹完後下一步一定是對節點訪問，什麼意思呢？</p><p>讓我們再進一步將規則講清楚，所謂的尋訪規則是對於『每個節點來說』，意思是『每到一個節點，我們都要重新依照這樣的優先順序進行判斷、執行』</p><p>換句話說，在中序規則下，我們總是不斷先前往左子樹，直到無法前往時，才執行訪問</p><p>還不熟沒關係，下面一步一步慢慢理解</p><h2 id="二元樹『資料結構』"><a href="#二元樹『資料結構』" class="headerlink" title="二元樹『資料結構』"></a>二元樹『資料結構』</h2><p>在開始實作二元樹的演算法前，我們需要先定義下二元樹的『資料結構』，資料結構是什麼？就是決定資料如何被存放、組織，而為演算法所用的意思。</p><p>讓我們用 JavaScript 來建構出『儲存樹節點』和『存儲樹』的資料容器。</p><blockquote><p>以下提供 class 版本的和，一般函數版本（class 在 JavaScript 中只是單純的語法糖）</p></blockquote><ul><li>儲存二元樹節點</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// class 版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span> (<span class="hljs-keyword">data</span>) &#123;<br>        <span class="hljs-comment">// 紀錄 父節點</span><br>        <span class="hljs-keyword">this</span>.parent = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 紀錄 右子樹根節點</span><br>        <span class="hljs-keyword">this</span>.rightChild = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 紀錄 左子樹根節點</span><br>        <span class="hljs-keyword">this</span>.leftChild = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 存儲 資料</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// function 版本</span><br>function TreeNode (<span class="hljs-keyword">data</span>) &#123;<br>    <span class="hljs-keyword">this</span>.parent = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.rightChild = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.leftChild = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>= <span class="hljs-keyword">data</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>儲存整棵樹</li></ul><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">// class 版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-variable">root</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">root</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 前序尋訪</span><br>    <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">node</span>) &#123;&#125; <br><br>    <span class="hljs-comment">// 中序尋訪</span><br>    <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 後序尋訪</span><br>    <span class="hljs-title function_">postOrder</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 層序尋訪</span><br>    <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 進階前序尋訪</span><br>    <span class="hljs-title function_">preOrderByParent</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 進階版中序尋訪</span><br>    <span class="hljs-title function_">inOrderByParent</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 進階版後序尋訪</span><br>    <span class="hljs-title function_">postOrderByParent</span>(<span class="hljs-params">node</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 前序尋訪規則下，尋找下一個節點</span><br>    <span class="hljs-title function_">preOrderSuccessor</span>(<span class="hljs-params">current</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 中序尋訪規則下，尋找下一個節點</span><br>    <span class="hljs-title function_">inOrderSuccessor</span>(<span class="hljs-params">current</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 後序尋訪規則下，尋找下一個節點</span><br>    <span class="hljs-title function_">postOrderSuccessor</span>(<span class="hljs-params">current</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 尋找最左節點</span><br>    <span class="hljs-title function_">leftMost</span>(<span class="hljs-params">current</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 尋找最右節點</span><br>    <span class="hljs-title function_">rightMost</span>(<span class="hljs-params">current</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// function 版本</span><br><span class="hljs-variable">function</span> <span class="hljs-title class_">BinaryTree</span> (<span class="hljs-variable">root</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">root</span>;<br>&#125;<br><br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">preOrder</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">inOrder</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">postOrder</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">levelOrder</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">preOrderByParent</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">inOrderByParent</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">postOrderByParent</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">node</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">preOrderSuccessor</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">current</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">inOrderSuccessor</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">current</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">postOrderSuccessor</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">current</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">leftMost</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">current</span>) &#123;&#125;<br><span class="hljs-title class_">BinaryTree</span>.<span class="hljs-property">prototype</span>.<span class="hljs-property">rightMost</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span> (<span class="hljs-variable">current</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="二元樹演算法『設計』（上）"><a href="#二元樹演算法『設計』（上）" class="headerlink" title="二元樹演算法『設計』（上）"></a>二元樹演算法『設計』（上）</h2><p>『演算法』是什麼意思？我想所謂的演算法就是『解決問題的過程、步驟、方法』</p><p>而此處我們要做的就是，將我們『人』所能理解的過程、步驟、方法，轉換成『電腦』能夠理解的過程、步驟，方法，也稱作演算法</p><p>為了達成這樣的目的（將尋訪規則，建構出電腦能執行的代碼），我們規劃了幾個階段</p><ul><li>將尋訪執行的『過程』，以『序列』的方式記錄下來</li><li>配合『尋訪規則』和『序列』紀錄，找出『共同處』</li><li>從『共同處』一步步建構出『代碼』</li><li>『檢驗』產出的代碼，是否符合演算法的需求</li><li>『優化』代碼</li></ul><h2 id="二元樹演算法『需求』（上）"><a href="#二元樹演算法『需求』（上）" class="headerlink" title="二元樹演算法『需求』（上）"></a>二元樹演算法『需求』（上）</h2><p>一個演算法，通常具有『輸入』和『輸出』，這個部分在上述的資料結構中大概定義完畢，此處在做更詳細的說明。</p><h3 id="preOrder-node"><a href="#preOrder-node" class="headerlink" title="preOrder (node)"></a>preOrder (node)</h3><ul><li>輸入： TreeNode 資料，作為『前序』尋訪起點</li><li>輸出： -</li><li>執行：前序尋訪，將訪問到的節點資料打印出來（使用遞回實作）</li></ul><h3 id="inOrder-node"><a href="#inOrder-node" class="headerlink" title="inOrder (node)"></a>inOrder (node)</h3><ul><li>輸入： TreeNode 資料，作為『中序』尋訪起點</li><li>輸出： -</li><li>執行：中序尋訪，將訪問到的節點資料打印出來（使用遞回實作）</li></ul><h3 id="postOrder-node"><a href="#postOrder-node" class="headerlink" title="postOrder (node)"></a>postOrder (node)</h3><ul><li>輸入： TreeNode 資料，作為『後序』尋訪起點</li><li>輸出： -</li><li>執行：後序尋訪，將訪問到的節點資料打印出來（使用遞回實作）</li></ul><h3 id="levelOrder-node"><a href="#levelOrder-node" class="headerlink" title="levelOrder (node)"></a>levelOrder (node)</h3><ul><li>輸入： TreeNode 資料，作為『層序』尋訪起點</li><li>輸出： -</li><li>執行：層序尋訪，將訪問到的節點資料打印出來（使用遞回實作）</li></ul><h3 id="preOrderByParent-node"><a href="#preOrderByParent-node" class="headerlink" title="preOrderByParent (node)"></a>preOrderByParent (node)</h3><ul><li>輸入： TreeNode 資料，作為『前序』尋訪起點</li><li>輸出： -</li><li>執行：前序尋訪，將訪問到的節點資料打印出來（使用下方 preOrderSuccessor 取代遞回實作）</li></ul><h3 id="inOrderByParent-node"><a href="#inOrderByParent-node" class="headerlink" title="inOrderByParent (node)"></a>inOrderByParent (node)</h3><ul><li>輸入： TreeNode 資料，作為『中序』尋訪起點</li><li>輸出： -</li><li>執行：中序尋訪，將訪問到的節點資料打印出來（使用下方 inOrderSuccessor 取代遞回實作）</li></ul><h3 id="postOrderByParent-node"><a href="#postOrderByParent-node" class="headerlink" title="postOrderByParent (node)"></a>postOrderByParent (node)</h3><ul><li>輸入： TreeNode 資料，作為『後序』尋訪起點</li><li>輸出： -</li><li>執行：後序尋訪，將訪問到的節點資料打印出來（使用下方 postOrderSuccessor 取代遞回實作）</li></ul><h3 id="preOrderSuccessor-current"><a href="#preOrderSuccessor-current" class="headerlink" title="preOrderSuccessor (current)"></a>preOrderSuccessor (current)</h3><ul><li>輸入： TreeNode 資料，任一樹中節點</li><li>輸出： 前序尋訪規則下，該輸入節點的下一個節點</li><li>執行： 前序尋訪的下一個節點尋找</li></ul><h3 id="inOrderSuccessor-current"><a href="#inOrderSuccessor-current" class="headerlink" title="inOrderSuccessor (current)"></a>inOrderSuccessor (current)</h3><ul><li>輸入： TreeNode 資料，任一樹中節點</li><li>輸出： 中序尋訪規則下，該輸入節點的下一個節點</li></ul><h3 id="postOrderSuccessor-current"><a href="#postOrderSuccessor-current" class="headerlink" title="postOrderSuccessor (current)"></a>postOrderSuccessor (current)</h3><ul><li>輸入： TreeNode 資料，任一樹中節點</li><li>輸出： 後序尋訪規則下，該輸入節點的下一個節點</li></ul><h3 id="leftMost-current"><a href="#leftMost-current" class="headerlink" title="leftMost (current)"></a>leftMost (current)</h3><ul><li>輸入： TreeNode 資料，任一樹中節點</li><li>輸出： 該輸入節點開始，左子樹方向，最左的節點</li></ul><h3 id="rightMost-current"><a href="#rightMost-current" class="headerlink" title="rightMost (current)"></a>rightMost (current)</h3><ul><li>輸入： TreeNode 資料，任一樹中節點</li><li>輸出： 該輸入節點開始，右子樹方向，最右的節點</li></ul><h2 id="演算法實作『前序』"><a href="#演算法實作『前序』" class="headerlink" title="演算法實作『前序』"></a>演算法實作『前序』</h2><h3 id="preOrder-node-1"><a href="#preOrder-node-1" class="headerlink" title="preOrder (node)"></a>preOrder (node)</h3><p>使用『遞迴 recursion』的概念即可快速的實作出，前序演算法。</p><p>為求效能、彈性接著會在實作 <code>preOrderByParent (node)</code> 來完成同樣效果的演算法。</p><p>我們知道前序尋訪優先順序是</p><ol><li>V: 訪問</li><li>L: 向左子樹移動</li><li>R: 向右子樹移動</li></ol><p>至此，讓我們將代碼建構出來</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function preOrder (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    if</span> (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        console</span>.log(` This <span class="hljs-keyword">node</span><span class="hljs-title">&#x27;s</span> data: $&#123;node.data&#125;`);<br>        preOrder(node.leftChild);<br>        preOrder(node.rightChild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通過依照前序尋訪的優先順序進行『遞回』呼叫，來達成『推疊 stack』先進後出的效果，即可完成。</p><blockquote><p>if 判斷式用來作為『遞回』的結束條件</p></blockquote><h3 id="preOrderSuccessor-current-1"><a href="#preOrderSuccessor-current-1" class="headerlink" title="preOrderSuccessor(current)"></a>preOrderSuccessor(current)</h3><p>上述遞迴（recursion）形式的尋訪，節點資料的訪問，和移動被包在同一個函式中，因此在實作對節點多種不同的資料訪問時，都需要重寫一個函式。</p><p>因此，為了將資料訪問 V，能夠獨立開來，我們需要實現另一種非遞迴版本的尋訪。</p><blockquote><p>引用整理自 <a href="http://alrightchiu.github.io/SecondRound/pages/about.html">Chiu CC</a> 內文：</p></blockquote><p>在實現非遞迴版本的尋訪前，我們需要建立一個函式來指出『下一個節點的位置』</p><p>讓我們依照前面提到的演算法設計階段來一步步建構出我們的代碼</p><h4 id="紀錄『序列』"><a href="#紀錄『序列』" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>我們思考下 preOrderSuccessor 函式的需求</p><ul><li>輸入：任意二元樹中的節點</li><li>輸出：下一個節點的位置</li></ul><p>換句話說，在 V-L-R 優先順序中，我們會從特定節點訪問完畢『出發』，找到下一個節點訪問完畢 『結束』</p><p>因此，我們紀錄的每個序列將會是以 V 開頭，V 結尾</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/pre-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 1 <span class="hljs-params">(A)</span> 前往 node 2 <span class="hljs-params">(B)</span><br>|<br>-  V    L    V<br>|<br>- # node 2 <span class="hljs-params">(B)</span> 前往 node 3 <span class="hljs-params">(D)</span><br>|<br>-  V    L    V<br>|<br>- # node 3 <span class="hljs-params">(D)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 4 <span class="hljs-params">(E)</span> 前往 node 5 <span class="hljs-params">(G)</span><br>|<br>-  V    L    V<br>|<br>- # node 5 <span class="hljs-params">(G)</span> 前往 node 6 <span class="hljs-params">(H)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VL)</span>   R    V <br>|<br>- # node 6 <span class="hljs-params">(H)</span> 前往 node 7 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 7 <span class="hljs-params">(C)</span> 前往 node 8 <span class="hljs-params">(F)</span><br>|<br>-  V    L    V<br>|<br>- # node 8 <span class="hljs-params">(F)</span> 前往 node 9 <span class="hljs-params">(I)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   R    V<br>|<br>- # node 9 <span class="hljs-params">(I)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(L)</span>  <span class="hljs-params">(R)</span>   P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』"><a href="#觀察『共同性』" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>從前序的規則 V-L-R 和上面的序列，我們可以很清楚的知道，節點的訪問 V 下一步就是左子樹的尋訪 L</p><p>而序列中可以清楚看到左子樹的尋訪 L，存在 2 種情況</p><ul><li>左子樹存在，前往並且訪問節點 V</li><li>左子樹不存在，輪到檢查右子樹 R</li></ul><h4 id="建構『代碼』"><a href="#建構『代碼』" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，讓我們將代碼建構出來</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> preOrderSuccessor (current) &#123;<br>    <span class="hljs-regexp">//</span> 左子樹存在，前往並且訪問節點<br>    <span class="hljs-keyword">if</span> (current.leftChild) &#123;<br>        return current.leftChild;<br>    &#125;<br>    <span class="hljs-regexp">//</span> 左子樹不存在，接著檢查右子樹<br>    <span class="hljs-keyword">if</span> (current.rightChild) &#123;<br>        <span class="hljs-regexp">//</span> ...<br>    &#125;<br><br>    <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-1"><a href="#紀錄『序列』-1" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>上一輪的演算法設計，我們已經處理掉『左子樹存在』的情況，讓我們簡化下序列，並接著觀察</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/pre-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 3 <span class="hljs-params">(D)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(L)</span> |  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 5 <span class="hljs-params">(G)</span> 前往 node 6 <span class="hljs-params">(H)</span><br>|<br>-  V   <span class="hljs-params">(L)</span> |  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VL)</span>   R    V <br>|<br>- # node 6 <span class="hljs-params">(H)</span> 前往 node 7 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(L)</span> |  <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 8 <span class="hljs-params">(F)</span> 前往 node 9 <span class="hljs-params">(I)</span><br>|<br>-  V   <span class="hljs-params">(L)</span> |   R    V<br>|<br>- # node 9 <span class="hljs-params">(I)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(L)</span> |  <span class="hljs-params">(R)</span>   P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-1"><a href="#觀察『共同性』-1" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>根據前序 V-L-R 和序列，當左子樹不存在時，接著就是判斷右子樹。同樣的右子樹的檢查也存在 2 種結果</p><ul><li>右子樹存在，前往並且訪問節點 V</li><li>右子樹不存在，整個子樹都已檢查完，返回父節點 P</li></ul><h4 id="建構『代碼』-1"><a href="#建構『代碼』-1" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，讓我們將代碼建構出來</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrderSuccessor</span> (<span class="hljs-literal">current</span>) &#123;<br>    if (<span class="hljs-literal">current</span>.leftChild) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">current</span>.leftChild<span class="hljs-comment">;</span><br>    &#125;<br><br>    if (<span class="hljs-literal">current</span>.rightChild) &#123;<br>        // 右子樹存在，訪問節點<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">current</span>.rightChild<span class="hljs-comment">;</span><br>    &#125;<br><br>    // 右子樹不存在<br>    //...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-2"><a href="#紀錄『序列』-2" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>接著我們同樣將『右子樹存在』這樣處理完畢的情況，從序列中排除，簡化畫面</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/pre-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 3 <span class="hljs-params">(D)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>  |  P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 5 <span class="hljs-params">(G)</span> 前往 node 6 <span class="hljs-params">(H)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>  |  P   <span class="hljs-params">(VL)</span>   R    V <br>|<br>- # node 6 <span class="hljs-params">(H)</span> 前往 node 7 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>  |  P   <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P   <span class="hljs-params">(VL)</span>   R    V<br>|<br>- # node 9 <span class="hljs-params">(I)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>  |  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-2"><a href="#觀察『共同性』-2" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>我們已經，完成完整一次的 V-L-R 前序的檢查，這樣的情況表示，以當前節點作為根節點的子樹，已尋訪完畢，因此我們向後退回父節點</p><p>而退回父節點同樣存在 2 種情況</p><ul><li>做為父節點的左子樹退回</li><li>做為父節點的右子樹退回</li></ul><p>綜合上面的觀察，我們可以得到這樣的性質</p><ul><li>做為父節點的左子樹退回，表示左子樹已尋訪完畢，根據 V-L-R 規則，接下來檢查右子樹 R</li><li>做為父節點的右子樹退回，表示右子樹已尋訪完畢，根據 V-L-R 規則，當前子樹也尋訪完畢再繼續往父節點退回</li></ul><p>因此，我們可以做出這樣的結論</p><ul><li>只要是『從左子樹退回，且該父節點不存在右子樹』，那麼就繼續往父節點退回</li><li>只要是『從右子樹退回』，那麼就繼續往父節點退回</li></ul><h4 id="建構『代碼』-2"><a href="#建構『代碼』-2" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，根據我們的結論，來建構下代碼</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrderSuccessor</span> (<span class="hljs-params">current</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (current.leftChild) &#123;<br>        <span class="hljs-keyword">return</span> current.leftChild;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (current.rightChild) &#123;<br>        <span class="hljs-keyword">return</span> current.rightChild;<br>    &#125;<br><br>    <span class="hljs-comment">// 右子樹不存在，退回父節點</span><br>    <span class="hljs-keyword">let</span> successor = current.parent;<br><br><br>    <span class="hljs-comment">// 只要是『從左子樹退回，且該父節點不存在右子樹』，那麼就繼續往父節點退回</span><br>    <span class="hljs-comment">// 只要是『從右子樹退回』，那麼就繼續往父節點退回</span><br>    <span class="hljs-keyword">while</span> (successor != <span class="hljs-literal">null</span> &amp;&amp; (successor.rightChild === current || successor.rightChild === <span class="hljs-literal">null</span>)) &#123;<br>        current = successor;<br>        successor = current.parent<br>    &#125;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-3"><a href="#紀錄『序列』-3" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>最後，我們來將剩下的序列完成</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/pre-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 3 <span class="hljs-params">(D)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>    P   <span class="hljs-params">(VL)</span>  |  R    V<br>|<br>- # node 5 <span class="hljs-params">(G)</span> 前往 node 6 <span class="hljs-params">(H)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>    P   <span class="hljs-params">(VL)</span>  | R    V <br>|<br>- # node 6 <span class="hljs-params">(H)</span> 前往 node 7 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>    P   <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P   <span class="hljs-params">(VL)</span> |  R    V<br>|<br>- # node 9 <span class="hljs-params">(I)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(L)</span>   <span class="hljs-params">(R)</span>    P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span>  P  <span class="hljs-params">(VLR)</span> | <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-3"><a href="#觀察『共同性』-3" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>最後，我們可以看到，父節點的退回，會直到『由左子樹退回，且該父節點存在右子樹』這樣的情況發生而停止（當退回到根節點，由於不能再退也會停止）</p><ul><li>右子樹存在，根據 V-L-R 前往，並且訪問 V</li></ul><h4 id="建構『代碼』-3"><a href="#建構『代碼』-3" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>讓我們將最後的代碼完成</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> preOrderSuccessor (<span class="hljs-keyword">current</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span>.leftChild) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>.leftChild;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span>.rightChild) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>.rightChild;<br>    &#125;<br><br>    let successor = <span class="hljs-keyword">current</span>.parent;<br>    <span class="hljs-keyword">while</span> (successor != <span class="hljs-keyword">null</span> &amp;&amp; (successor.rightChild === <span class="hljs-keyword">current</span> || successor.rightChild === <span class="hljs-keyword">null</span>)) &#123;<br>        <span class="hljs-keyword">current</span> = successor;<br>        successor = <span class="hljs-keyword">current</span>.parent<br>    &#125;<br><br>    // 退回之父節點，存在右子樹，前往並訪問節點<br>    <span class="hljs-keyword">if</span> (successor != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> successor.rightChild;<br>    <br>    <span class="hljs-keyword">return</span> successor;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="preOrderByParent-node-1"><a href="#preOrderByParent-node-1" class="headerlink" title="preOrderByParent(node)"></a>preOrderByParent(node)</h3><p>上面，我們已經完成，前序規則下，下一個節點的找尋函式，那麼讓我們將原本遞迴（recursion）方式寫成的前序演算法改寫下吧</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrderByParent</span> (<span class="hljs-params">node</span>) &#123;<br>    let current = node;<br><br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">` <span class="hljs-subst">$&#123;current.data&#125;</span>`</span>); <span class="hljs-comment">// Visiting</span><br>        current = preOrderSuccessor(current); <span class="hljs-comment">// Traversal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="演算法實作『中序』"><a href="#演算法實作『中序』" class="headerlink" title="演算法實作『中序』"></a>演算法實作『中序』</h2><h3 id="inOrder-node-1"><a href="#inOrder-node-1" class="headerlink" title="inOrder (node)"></a>inOrder (node)</h3><p>使用『遞迴 recursion』的概念即可快速的實作出，中序演算法。</p><p>為求效能、彈性接著會在實作 <code>inOrderByParent (node)</code> 來完成同樣效果的演算法。</p><p>我們知道中序尋訪優先順序是</p><ol><li>L: 向左子樹移動</li><li>V: 訪問</li><li>R: 向右子樹移動</li></ol><p>至此，讓我們將代碼建構出來</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function inOrder (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    if</span> (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        preOrder</span>(node.leftChild);<br>        console.log(` This <span class="hljs-keyword">node</span><span class="hljs-title">&#x27;s</span> data: $&#123;node.data&#125;`);<br>        preOrder(node.rightChild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通過依照中序尋訪的優先順序進行『遞回』呼叫，來達成『推疊 stack』先進後出的效果，即可完成。</p><blockquote><p>if 判斷式用來作為『遞回』的結束條件</p></blockquote><h3 id="inOrderSuccessor-current-1"><a href="#inOrderSuccessor-current-1" class="headerlink" title="inOrderSuccessor (current)"></a>inOrderSuccessor (current)</h3><p>如同前述，遞迴（recursion）形式的尋訪，對於節點資料訪問開始有多種不同形式時，因為演算法設計上的耦合性，所以必須每次都重寫一個函式。</p><p>因此，為了將 Visiting 行為獨立開來，我們需要實現非遞迴版本的演算法。</p><blockquote><p>引用整理自 <a href="http://alrightchiu.github.io/SecondRound/pages/about.html">Chiu CC</a> 內文：</p></blockquote><p>而在實現非遞迴版本的尋訪前，我們有些前置作業要做</p><p>首先我們需要實現一函式，當輸入一節點時，能夠輸出『下一個節點的位置』</p><p>接下來，讓我們依照前面提到的演算法設計階段來一步步建構出我們的代碼</p><blockquote><p>紀錄序列 -&gt; 觀察共同性 -&gt; 建構代碼</p></blockquote><h4 id="紀錄『序列』-4"><a href="#紀錄『序列』-4" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>我們思考下 inOrderSuccessor 函式的需求</p><ul><li>輸入：任意二元樹中的節點</li><li>輸出：下一個節點的位置</li></ul><p>換句話說，我們可以解成，我們需要找出 2 次連續的 Visiting 之間的規則</p><p>因此，我們紀錄的每筆序列將會是以 V 開頭，V 結尾</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/in-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 1 <span class="hljs-params">(D)</span> 前往 node 2 <span class="hljs-params">(B)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 2 <span class="hljs-params">(B)</span> 前往 node 3 <span class="hljs-params">(G)</span><br>|<br>-  V    R    L   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 3 <span class="hljs-params">(G)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 4 <span class="hljs-params">(E)</span> 前往 node 5 <span class="hljs-params">(H)</span><br>|<br>-  V    R   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 5 <span class="hljs-params">(H)</span> 前往 node 6 <span class="hljs-params">(A)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P  <span class="hljs-params">(LVR)</span>  P  <span class="hljs-params">(LVR)</span>  P  <span class="hljs-params">(L)</span>  V<br>|<br>- # node 6 <span class="hljs-params">(A)</span> 前往 node 7 <span class="hljs-params">(F)</span><br>|<br>-  V    R    L    V<br>|<br>- # node 7 <span class="hljs-params">(F)</span> 前往 node 8 <span class="hljs-params">(I)</span><br>|<br>-  V    R   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 8 <span class="hljs-params">(I)</span> 前往 node 9 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P  <span class="hljs-params">(LVR)</span>  P   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 9 <span class="hljs-params">(C)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(R)</span>   P  <span class="hljs-params">(LVR)</span>  <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-4"><a href="#觀察『共同性』-4" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>從中序規則 L-V-R 和上方序列，我們可以知道，節點訪問 Visiting 完畢的下一步就是右子樹的尋訪 R</p><p>而由於二元樹的特性只有至多 2 個子節點，因此我們可以很清楚知道右子樹的尋訪 R，存在 2 種情況</p><ul><li>右子樹存在，前往</li><li>右子樹不存在，L-V-R 結束，表示子樹尋訪完畢，退回父節點</li></ul><h4 id="建構『代碼』-4"><a href="#建構『代碼』-4" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，讓我們先將代碼建構出來</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> inOrderSuccessor (current) &#123;<br>    <span class="hljs-regexp">//</span> 右子樹存在<br>    <span class="hljs-keyword">if</span> (current.rightChild) &#123;<br>        <span class="hljs-regexp">//</span>...<br>    &#125;<br>    <span class="hljs-regexp">//</span> 右子樹不存在<br>    let successor = current.parent;<br><br>    <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-5"><a href="#紀錄『序列』-5" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>上一輪的代碼建構，並未實現 Visiting 節點訪問，因此我們仍繼續保留序列，加上垂直線紀錄我們觀察的進度</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/in-order.png"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs 1c">- <span class="hljs-meta"># node 1 (D) 前往 node 2 (B)</span><br><span class="hljs-string">|</span><br>-  V   (R)   P  <span class="hljs-string">| (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 2 (B) 前往 node 3 (G)</span><br><span class="hljs-string">|</span><br>-  V    R  <span class="hljs-string">|  L   (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 3 (G) 前往 node 4 (E)</span><br><span class="hljs-string">|</span><br>-  V   (R)   P <span class="hljs-string">|  (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 4 (E) 前往 node 5 (H)</span><br><span class="hljs-string">|</span><br>-  V    R  <span class="hljs-string">| (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 5 (H) 前往 node 6 (A)</span><br><span class="hljs-string">|</span><br>-  V   (R)   P <span class="hljs-string">| (LVR)  P  (LVR)  P  (L)  V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 6 (A) 前往 node 7 (F)</span><br><span class="hljs-string">|</span><br>-  V    R  <span class="hljs-string">|  L    V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 7 (F) 前往 node 8 (I)</span><br><span class="hljs-string">|</span><br>-  V    R  <span class="hljs-string">| (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 8 (I) 前往 node 9 (C)</span><br><span class="hljs-string">|</span><br>-  V   (R)   P <span class="hljs-string">| (LVR)  P   (L)   V</span><br><span class="hljs-string">|</span><br>- <span class="hljs-meta"># node 9 (C) 前往 null</span><br><span class="hljs-string">|</span><br>-  V   (R)   P <span class="hljs-string">| (LVR)  (P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-5"><a href="#觀察『共同性』-5" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>根據中序 L-V-R 規則，我們知道，一個節點的尋訪最優先執行的就是左子樹的前往</p><p>換句話說，當我們前往一個節點時，我們就會不斷地檢查該節點的左子樹、的左子樹、的左子樹<br>，直到左子樹不存在，我們才得以進行 L-V-R 規則中的 V</p><p>綜合先前結果，我們做出以下結論</p><ul><li>右子樹存在，前往並且找到最左的左子樹進行訪問 V</li></ul><h4 id="建構『代碼』-5"><a href="#建構『代碼』-5" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>讓我們將剛剛未完成的代碼補上</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> inOrderSuccessor (current) &#123;<br>    <span class="hljs-keyword">if</span> (current.rightChild) &#123;<br>        <span class="hljs-comment">// 找到最左的左子樹</span><br>        return left<span class="hljs-constructor">Most(<span class="hljs-params">current</span>.<span class="hljs-params">rightChild</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> successor = current.parent;<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此處，補充下 <code>leftMost (current)</code> 函式（找出節點最左的左子樹根節點）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> leftMost (<span class="hljs-keyword">current</span>) &#123;<br>    // 不斷確認左子樹是否存在並前往<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">current</span>.leftChild) &#123;<br>        <span class="hljs-keyword">current</span> = <span class="hljs-keyword">current</span>.leftChild;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">current</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-6"><a href="#紀錄『序列』-6" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>上一輪的演算法設計，我們已經處理完『右子樹存在』的情況，就是找尋最左的左子樹，並且進行訪問。因此，讓我們去除已完成的部分，簡化下序列</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/in-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 1 <span class="hljs-params">(D)</span> 前往 node 2 <span class="hljs-params">(B)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P  | <span class="hljs-params">(L)</span>   V<br>|<br>- # node 3 <span class="hljs-params">(G)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P |  <span class="hljs-params">(L)</span>   V<br>|<br>- # node 5 <span class="hljs-params">(H)</span> 前往 node 6 <span class="hljs-params">(A)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P | <span class="hljs-params">(LVR)</span>  P  <span class="hljs-params">(LVR)</span>  P  <span class="hljs-params">(L)</span>  V<br>|<br>- # node 8 <span class="hljs-params">(I)</span> 前往 node 9 <span class="hljs-params">(C)</span><br>|<br>-  V   <span class="hljs-params">(R)</span>   P | <span class="hljs-params">(LVR)</span>  P   <span class="hljs-params">(L)</span>   V<br>|<br>- # node 9 <span class="hljs-params">(C)</span> 前往 null<br>|<br>-  V   <span class="hljs-params">(R)</span>   P | <span class="hljs-params">(LVR)</span>  <span class="hljs-params">(P)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-6"><a href="#觀察『共同性』-6" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>剩下的情況，都是『右子樹不存在』，而中序規則 L-V-R，右子樹的檢查完畢，所代表的意義就是當前子樹已尋訪完畢</p><p>因此，下一步要做的就是退回父節點，看看還有沒有尚未尋訪的部分</p><p>父節點的退回，由於二元樹的特性，同樣存在 2 種情況</p><ul><li>由左子樹退回父節點</li><li>由右子樹退回父節點</li></ul><p>這 2 種情況我們也可以在序列中觀察到，分別就是『P (L)』和『P (LVR)』，同時我們觀察到後者有出現重複執行的現象，前者則是執行完就進行節點訪問 V</p><p>讓我們從 L-V-R 規則思考，就可以理解原因了</p><ul><li><p>由左子樹退回父節點，的另一層含義就是對於該父節點，左子樹已尋訪完畢；那麼根據 L-V-R 規則，我們知道當左子樹的前往 L 都執行完畢，下一步就是節點的訪問 V</p></li><li><p>由右子樹退回父節點，同樣也表示右子樹已尋訪完畢；根據 L-V-R 規則，我們知道右子樹的前往是最後一步，表示當前子樹也已尋訪完畢，因此我們就繼續往父節點的方向退回</p></li></ul><p>上述就是，序列現象的成因</p><p>因此我們可以做出這樣的結論</p><ul><li>只要是『從右子樹退回』，那麼就繼續往父節點方向移動</li><li>只要是『從左子樹退回』，那麼我們就進行節點訪問</li></ul><h4 id="建構『代碼』-6"><a href="#建構『代碼』-6" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，根據我們的結論，來建構出剩下未完成的代碼</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> inOrderSuccessor (<span class="hljs-keyword">current</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">current</span>.rightChild) &#123;<br>        <span class="hljs-keyword">return</span> leftMost(<span class="hljs-keyword">current</span>.rightChild);<br>    &#125;<br><br>    let successor = <span class="hljs-keyword">current</span>.parent;<br>    // 從右子樹退回，就繼續往父節點方向退<br>    <span class="hljs-keyword">while</span> (successor != <span class="hljs-keyword">null</span> &amp;&amp; successor.rightChild === <span class="hljs-keyword">current</span>) &#123;<br>        <span class="hljs-keyword">current</span> = successor;<br>        successor = <span class="hljs-keyword">current</span>.parent;<br>    &#125; <br>    // 從左子樹退回，就進行節點訪問<br>    <span class="hljs-keyword">return</span> successor;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="inOrderByParent-node-1"><a href="#inOrderByParent-node-1" class="headerlink" title="inOrderByParent (node)"></a>inOrderByParent (node)</h3><p>上述，我們完成了前置作業，讓我們接著完成中序尋訪（非遞迴版本）吧</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrderByParent</span> (<span class="hljs-params">node</span>) &#123;<br>    let current = leftMost(node);<br><br>    <span class="hljs-keyword">while</span> (current) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">` <span class="hljs-subst">$&#123;current.data&#125;</span> `</span>); <span class="hljs-comment">// Visiting</span><br>        current = inOrderSuccessor(current); <span class="hljs-comment">// Traversal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="演算法實作『後序』"><a href="#演算法實作『後序』" class="headerlink" title="演算法實作『後序』"></a>演算法實作『後序』</h2><h3 id="postOrder-node-1"><a href="#postOrder-node-1" class="headerlink" title="postOrder (node)"></a>postOrder (node)</h3><p>使用『遞迴 recursion』的概念即可快速的實作出，後序演算法。</p><p>為求效能、彈性接著會在實作 <code>postOrderByParent (node)</code> 來完成同樣效果的演算法。</p><p>我們知道後序尋訪優先順序是</p><ol><li>L: 向左子樹移動</li><li>R: 向右子樹移動</li><li>V: 訪問</li></ol><p>至此，讓我們將代碼建構出來</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function postOrder (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    if</span> (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        preOrder</span>(node.leftChild);<br>        preOrder(node.rightChild);<br>        console.log(` This <span class="hljs-keyword">node</span><span class="hljs-title">&#x27;s</span> data: $&#123;node.data&#125;`);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通過依照後序尋訪的優先順序進行『遞回』呼叫，來達成『推疊 stack』先進後出的效果，即可完成。</p><blockquote><p>if 判斷式用來作為『遞回』的結束條件</p></blockquote><h3 id="postOrderSuccessor-current-1"><a href="#postOrderSuccessor-current-1" class="headerlink" title="postOrderSuccessor (current)"></a>postOrderSuccessor (current)</h3><p>遞迴（recursion）形式的尋訪，將『節點的訪問』和『尋訪』耦合再一起，在某些時候需要有不同形式的節點訪問時，必須每次都重寫一個函式。</p><p>因此，為了將 Visiting 行為獨立開來，我們需要實現非遞迴版本的演算法</p><blockquote><p>引用整理自 <a href="http://alrightchiu.github.io/SecondRound/pages/about.html">Chiu CC</a> 內文：</p></blockquote><p>而在實現非遞迴版本的尋訪前，我們需要建立一個函式來指出『下一個節點的位置』</p><p>讓我們依照前面提到的演算法設計階段來一步步建構出我們的代碼</p><h4 id="紀錄『序列』-7"><a href="#紀錄『序列』-7" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>讓我們思考下 postOrderSuccessor 函式的需求</p><ul><li>輸入：任意二元樹中的節點</li><li>輸出：下一個節點的位置</li></ul><p>換句話說，在 L-R-V 優先順序中，我們會從特定節點訪問完畢『出發』，找到下一個節點訪問完畢『結束』</p><p>因此，我們紀錄的每個序列將會是以 V 開頭，V 結尾</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/post-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 1 <span class="hljs-params">(D)</span> 前往 node 2 <span class="hljs-params">(G)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R    L    <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 2 <span class="hljs-params">(G)</span> 前往 node 3 <span class="hljs-params">(H)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R   <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 3 <span class="hljs-params">(H)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V  <br>|<br>- # node 4 <span class="hljs-params">(E)</span> 前往 node 5 <span class="hljs-params">(B)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 5 <span class="hljs-params">(B)</span> 前往 node 6 <span class="hljs-params">(I)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R    L    <span class="hljs-params">(L)</span>   R   <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 6 <span class="hljs-params">(I)</span> 前往 node 7 <span class="hljs-params">(F)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 7 <span class="hljs-params">(F)</span> 前往 node 8 <span class="hljs-params">(C)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 8 <span class="hljs-params">(C)</span> 前往 node 9 <span class="hljs-params">(A)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 9 <span class="hljs-params">(A)</span> 前往 null<br>|<br>-  V    P   <span class="hljs-params">(LR)</span> <span class="hljs-params">(V)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-7"><a href="#觀察『共同性』-7" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>從後序規則 L-R-V 和上面的序列，我們可以知道，節點的訪問 V 所代表的意義為『當前子樹的尋訪完畢』，因此下一步就是『返回父節點』</p><p>由於二元樹的特性（2 個子節點），因此返回父節點同樣存在 2 種情況</p><ul><li>由左子樹返回，根據 L-R-V 規則，左子樹的尋訪完畢，接著就是前往右子樹</li><li>由右子樹返回，根據 L-R-V 規則，右子樹的尋訪完畢，接著就是進行節點訪問</li></ul><p>因此，我們可得到這樣的結論</p><ul><li>右子樹返回，我們就進行節點訪問</li><li>左子樹返回，另外處理</li></ul><h4 id="建構『代碼』-7"><a href="#建構『代碼』-7" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><p>至此，讓我們建構出代碼</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> postOrderSuccessor (current) &#123;<br>    let successor = current.parent;<br><br>    <span class="hljs-regexp">//</span> 父節點不存在（表示已回到根節點）<br>    <span class="hljs-keyword">if</span> (!successor) &#123;<br>        return successor;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 父節點存在<br>    <span class="hljs-regexp">//</span> 由右子樹返回，我們就進行節點訪問<br>    <span class="hljs-keyword">if</span> (successor.righChild === current) &#123;<br>        return successor;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 左子樹返回，另外處理<br>    <span class="hljs-regexp">//</span>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="紀錄『序列』-8"><a href="#紀錄『序列』-8" class="headerlink" title="紀錄『序列』"></a>紀錄『序列』</h4><p>讓我們再次紀錄序列，序列圖和上面一致，並無更動</p><p><img src="/2022/04/05/JavaScript-%E4%BA%8C%E5%85%83%E6%A8%B9%EF%BC%9A%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%BE%8C%E5%BA%8F%E3%80%81%E5%B1%A4%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/post-order.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- # node 1 <span class="hljs-params">(D)</span> 前往 node 2 <span class="hljs-params">(G)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R    L    <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 2 <span class="hljs-params">(G)</span> 前往 node 3 <span class="hljs-params">(H)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R   <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 3 <span class="hljs-params">(H)</span> 前往 node 4 <span class="hljs-params">(E)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V  <br>|<br>- # node 4 <span class="hljs-params">(E)</span> 前往 node 5 <span class="hljs-params">(B)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 5 <span class="hljs-params">(B)</span> 前往 node 6 <span class="hljs-params">(I)</span><br>|<br>-  V    P   <span class="hljs-params">(L)</span>   R    L    <span class="hljs-params">(L)</span>   R   <span class="hljs-params">(LR)</span>   V<br>|<br>- # node 6 <span class="hljs-params">(I)</span> 前往 node 7 <span class="hljs-params">(F)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 7 <span class="hljs-params">(F)</span> 前往 node 8 <span class="hljs-params">(C)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 8 <span class="hljs-params">(C)</span> 前往 node 9 <span class="hljs-params">(A)</span><br>|<br>-  V    P   <span class="hljs-params">(LR)</span>  V<br>|<br>- # node 9 <span class="hljs-params">(A)</span> 前往 null<br>|<br>-  V    P   <span class="hljs-params">(LR)</span> <span class="hljs-params">(V)</span><br></code></pre></td></tr></table></figure><h4 id="觀察『共同性』-8"><a href="#觀察『共同性』-8" class="headerlink" title="觀察『共同性』"></a>觀察『共同性』</h4><p>在後序 L-R-V 規則下，左子樹的前往和右子樹的前往是接連再一起的，那這是什麼意思？</p><p>換句話說，一個節點會不斷地先往左子樹尋訪到盡頭，接著前往右子樹，再不斷地往左子樹尋訪，重複這樣的迴圈，直到這個盡頭不再存在右子樹可以前往，就結束了 L-R-V 規則中的 L-R，至此進行節點訪問 V</p><p>因此，我們可以做出這樣的結論</p><ul><li>直到尋找到『葉節點』前，後序尋訪會不斷地持續下去</li></ul><h4 id="建構『代碼』-8"><a href="#建構『代碼』-8" class="headerlink" title="建構『代碼』"></a>建構『代碼』</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> postOrderSuccessor (<span class="hljs-keyword">current</span>) &#123;<br>    let successor = <span class="hljs-keyword">current</span>.parent;<br><br>    <span class="hljs-keyword">if</span> (!successor) &#123;<br>        <span class="hljs-keyword">return</span> successor;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (successor.rightChild === <span class="hljs-keyword">current</span>) &#123;<br>        <span class="hljs-keyword">return</span> successor;<br>    &#125;<br><br>    // 左子樹返回父節點，檢查父節點是否存在右子樹<br>    <span class="hljs-keyword">current</span> = successor.rightChild;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">current</span>) &#123;<br>        // 找到最左子樹<br>        successor = leftMost(<span class="hljs-keyword">current</span>);<br><br>        // 前往右子樹<br>        <span class="hljs-keyword">current</span> = successor.rightChild;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> successor;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="postOrderByParent-node-1"><a href="#postOrderByParent-node-1" class="headerlink" title="postOrderByParent (node)"></a>postOrderByParent (node)</h3><p>前置作業完成，接者我們來建構出非遞迴版本的後續尋訪</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">function postOrderByParent (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    let</span> current = null;<br>    <br>    while (<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">        current</span> = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        node</span> = leftMost(current);<br><br>        current = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        node</span> = current.rightChild;<br>    &#125;<br><br>    while (current) &#123;<br>        console.log(` $&#123;current.data&#125; `); // Visiting<br>        current = postOrderSuccessor(current); // Traversal<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="層序-Level-order"><a href="#層序-Level-order" class="headerlink" title="層序 Level-order"></a>層序 Level-order</h2><p>一開始所提到的 Full Binary Tree 和 Complete Binary Tree 即是以層序的方式安排節點</p><ul><li>層序：從根節點開始，由上至下，由左至右尋訪</li></ul><p>在層序的演算法實作上，我們會用到『佇列 queue』的概念；佇列是一種抽象的（概念性）的資料結構，具有『先進先出』的特性</p><p>讓我們開始建構代碼</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">levelOrder</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-comment">// 建立一個陣列</span><br>    const queue = [];<br><br>    <span class="hljs-comment">// 將根節點加入佇列</span><br>    queue.<span class="hljs-built_in">push</span>(root);<br><br>    <span class="hljs-comment">// 檢查佇列是否為空，為空表示尋訪完畢</span><br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-built_in">length</span> !== <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 從頭（最早加入的）取出資料 </span><br>        let current = queue.shift();<br><br>        <span class="hljs-comment">// 節點訪問 Visiting</span><br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">` <span class="hljs-subst">$&#123;current.data&#125;</span>`</span>);<br><br>        <span class="hljs-comment">// Level 是由左至右，因此先將左子節點加入佇列</span><br>        <span class="hljs-keyword">if</span> (current.leftChild !== <span class="hljs-literal">null</span>)<br>            queue.<span class="hljs-built_in">push</span>(current.leftChild);<br>        <br>        <span class="hljs-comment">// 再將右子節點加入佇列</span><br>        <span class="hljs-keyword">if</span> (current.rightChild !== <span class="hljs-literal">null</span>)<br>            queue.<span class="hljs-built_in">push</span>(current.rightChild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，就可以達成層層、並且由左至右訪問樹的節點</p><h2 id="JavaScript-代碼檔案"><a href="#JavaScript-代碼檔案" class="headerlink" title="JavaScript 代碼檔案"></a>JavaScript 代碼檔案</h2><p><a href="code/binary-tree.js">二元樹演算法實作（上）：binary-tree.js</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, structure, tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 實作資料結構：樹，基礎觀念</title>
    <link href="/2022/03/26/JavaScript-%E5%AF%A6%E4%BD%9C%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%EF%BC%9A%E6%A8%B9%EF%BC%8C%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/"/>
    <url>/2022/03/26/JavaScript-%E5%AF%A6%E4%BD%9C%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%EF%BC%9A%E6%A8%B9%EF%BC%8C%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>本篇文章依照自己的理解和話，整理 <a href="http://alrightchiu.github.io/SecondRound/pages/about.html">Chiu CC 部落格</a> 有關於樹的一系列以 C++ 實作的文章重點。</p><h2 id="『樹』的宏觀世界（集合關係）"><a href="#『樹』的宏觀世界（集合關係）" class="headerlink" title="『樹』的宏觀世界（集合關係）"></a>『樹』的宏觀世界（集合關係）</h2><p><img src="/2022/03/26/JavaScript-%E5%AF%A6%E4%BD%9C%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%EF%BC%9A%E6%A8%B9%EF%BC%8C%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/tree-world.png"></p><p>依據越嚴格的定義，資料結構依序由 Graph 圖、Tree 樹、Binary Tree 二元樹、Binary Search Tree 二元搜尋樹、Red Black 紅黑樹發展。</p><ul><li>Graph：存在 cycle 的樹，則稱作 圖。</li><li>Tree：不存在 cycle 情形，且無特別限制 child 數量的樹。</li><li>Binary Tree：每個 node 只存在至多 2 個 child，稱之。</li><li>Binary Search Tree (BST)：Binary Tree 再加上『鍵值大小規則限制』，稱之。</li><li>Red Black Tree：以 BST 為基礎，添加顏色平衡樹高，簡短搜尋時間，稱之。</li></ul><h2 id="術語認識（定義）"><a href="#術語認識（定義）" class="headerlink" title="術語認識（定義）"></a>術語認識（定義）</h2><h3 id="樹"><a href="#樹" class="headerlink" title="樹"></a>樹</h3><ul><li>tree：每個 node 只存在一個 parent，並且尋找特定 node 時只存在一條 path。</li></ul><h3 id="基礎"><a href="#基礎" class="headerlink" title="基礎"></a>基礎</h3><ul><li>node：節點。</li><li>edge：兩相相鄰節點之間的連線，邊。</li><li>cycle：節點間，彼此互相指向，形成封閉迴圈。</li></ul><h3 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h3><ul><li>parent &#x2F; child：當 A 節點指向 B 節點，則 A 為 parent，B 為 child。</li><li>siblings：擁有相同 parent 的節點們。</li><li>desendant：所有的 child，包括 child 的 child 都稱之為。</li><li>ancestor：所有的 parent，包括 parent 的 parent 都稱之為。</li><li>path：node 和 edge 組成的序列。</li><li>level：root 被定義為 level 1，至此每經過一個 parent 往上加 1。</li><li>height of node：height 指的是 edge 的數量。一個 node 的 hieght 為其最遠的子代中間經過的 edge 數。</li><li>height of tree：height 指的是 edge 的數量。樹高即為 root 的 height。</li><li>depth：depth 和 height 一樣指的是 edge 的數量；而與之不同處為，height 指的與最遠子代間經過的 edge 數，而 depth 指的是與 root 間的 edge 數。</li></ul><h3 id="樹的元素"><a href="#樹的元素" class="headerlink" title="樹的元素"></a>樹的元素</h3><ul><li>root：樹結構中最上層的節點（parent &#x3D; NULL）</li><li>degree：單一節點所擁有的子樹數量</li><li>leaf &#x2F; external node：子樹數量為 0 的節點</li><li>internal node：至少有 1 個子樹的節點</li></ul><h2 id="樹的使用"><a href="#樹的使用" class="headerlink" title="樹的使用"></a>樹的使用</h2><p>樹適合用以解決具有階層結構（hierarchical structure）的問題。</p><blockquote><p>階層結構：具有明確的先後次序</p></blockquote><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><ul><li><a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html">資料結構系列介紹 (以 C++ 實作)</a></li><li><a href="http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=fae2b084a5b01dda06bf7d92b9aebd18645f9edab">樹名詞介紹</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript, structure, tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH 連線指令</title>
    <link href="/2022/03/26/SSH-%E9%80%A3%E7%B7%9A%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/03/26/SSH-%E9%80%A3%E7%B7%9A%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-SSH-加密連線方式"><a href="#1-SSH-加密連線方式" class="headerlink" title="1. SSH 加密連線方式"></a>1. SSH 加密連線方式</h2><p>要從 A（本地）使用 SSH 加密連線到 B（伺服器）前， 一組成對的『公、私鑰』必須分別存在 A 和 B 中。</p><p>只要 B 的 SSH Daemon 程序在運行中，A 就可以使用 SSH Client 程序發起加密連線。</p><blockquote><p>SSH 預設連線端口為 22</p></blockquote><p>一般的加密連線指令：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ ssh -i <span class="hljs-tag">&lt;<span class="hljs-name">private-key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>@<span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>-i : identity 參數：使用指定私鑰進行 SSH 連線</p></blockquote><p>當使用 <code>ssh-agent</code> 來管理私鑰後，我們的連線指令可以縮短成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ ssh <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>@<span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span><br></code></pre></td></tr></table></figure><p>當配置 ssh_config 設定檔後，連線指令可以更彈性 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ ssh <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>host : ssh_config 文件中自行定義名稱</p></blockquote><h2 id="2-系統-amp-使用者層級"><a href="#2-系統-amp-使用者層級" class="headerlink" title="2. 系統 &amp; 使用者層級"></a>2. 系統 &amp; 使用者層級</h2><p>在 Mac 和 Linux 環境下（Windows 不確定），SSH 的兩個層級資料分別放在</p><ul><li><code>/etc/ssh/</code><blockquote><p>通常會有 ssh_config（客戶端設定檔）、sshd_config (伺服器端設定檔)</p></blockquote></li><li><code>~/.ssh</code><blockquote><p>通常會有 id_rsa (預設私鑰名稱), id_rsa.pub (預設公鑰名稱), known_hosts (紀錄連線過 IP、公鑰), authorized_keys (紀錄公鑰)</p></blockquote></li></ul><p>設定檔套用順序，先套用系統層級，在套用使用者層級；換句話說，ssh_config、sshd_config 也可以寫在 <code>~/.ssh</code> 中。</p><p>公鑰、私鑰名稱，可以在使用 <code>ssh-keygen</code> 生成時指定名稱（再多把鑰匙管理匙通常會在後方加上額外訊息 <code>id_rsa.aws.11.22.123.123</code>）。</p><p><code>known_hosts</code> 紀錄曾經連線過的 IP 和對應的公鑰。</p><p><code>authorized_keys</code> 當作為 SSH 伺服器端時，會將授權的公鑰紀錄在這個檔案中。</p><h2 id="3-金鑰對生成-key-pair"><a href="#3-金鑰對生成-key-pair" class="headerlink" title="3. 金鑰對生成 key pair"></a>3. 金鑰對生成 key pair</h2><p>SSH 的金鑰生成，需要使用到 <code>ssh-keygen</code> 指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ssh-keygen -t rsa -<span class="hljs-selector-tag">b</span> <span class="hljs-number">4096</span> -C <span class="hljs-string">&quot;for@ip@who&quot;</span> -f ~/.ssh/id_rsa<span class="hljs-selector-class">.for</span><span class="hljs-selector-class">.ip</span> -P <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>-t</code> 指定加密方式，使用 <code>man ssh-keygen</code> 指令可以看到有四種設定值 <code>[dsa | ecdsa | ed25519 | rsa]</code></li><li><code>-b</code> 指定加密長度，rsa 預設為 3072 bits (1024 ~ 4096 bits) 其餘使用 <code>man ssh-keygen</code> 即可查閱</li><li><code>-C</code> 撰寫註解，幫助管理鑰匙。自己會寫上用途、IP、誰</li><li><code>-f</code> 指定輸出檔案位置，和評論差不多，後方也會加上用途、IP、誰</li><li><code>-P</code> 可加可不加，指定通關密碼為空（不設定意思），不加的話會詢問你密碼要設定多少</li></ul><p>命令執行後，就可以看到生成的兩把鑰匙（公、私鑰）儲存在 <code>~/.ssh</code> 中</p><h2 id="4-公鑰管理"><a href="#4-公鑰管理" class="headerlink" title="4. 公鑰管理"></a>4. 公鑰管理</h2><p>鑰匙生成後，公鑰需要傳送到 SSH 伺服器端。</p><h3 id="4-1-GitHub-公鑰設定"><a href="#4-1-GitHub-公鑰設定" class="headerlink" title="4.1 GitHub 公鑰設定"></a>4.1 GitHub 公鑰設定</h3><p>以 GitHub 來說，鑰匙要手動貼到指定頁面儲存</p><p>Mac 環境下，將公鑰內容儲存到剪貼簿中，直接到 GitHub 指定頁面 <code>Ctrl + V</code> 貼上即可</p><p>沒有 <code>pbcopy</code> 指令就直接 <code>cat</code> 出來手動複製即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub | pbcopy</span> <br></code></pre></td></tr></table></figure><h3 id="4-2-AWS-EC2-公鑰設定"><a href="#4-2-AWS-EC2-公鑰設定" class="headerlink" title="4.2 AWS EC2 公鑰設定"></a>4.2 AWS EC2 公鑰設定</h3><p>如果伺服器可以直接連線的話就直接使用 <code>ssh-copy-id</code> 將公鑰傳送過去即可，這個指令會直接將公鑰寫入伺服器上的 <code>~/.ssh/authorized_keys</code> 檔案中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ ssh-<span class="hljs-keyword">copy</span>-id <span class="hljs-symbol">&lt;your-public-key&gt;</span> <span class="hljs-symbol">&lt;user&gt;</span>@<span class="hljs-symbol">&lt;ip&gt;</span><br></code></pre></td></tr></table></figure><p>如果像 AWS EC2 首次就要使用預設金鑰連線的話，可以用下面方法</p><p>Mac 環境下開啟終端機</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ ssh -i <span class="hljs-tag">&lt;<span class="hljs-name">default-private-key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>@<span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 EC2 給的預設私鑰進行連線，成功連線後不要關閉，<code>Ctrl + T</code> 開一個新的終端機</p><p>使用 SCP 檔案加密傳輸，將公鑰傳到伺服器上</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scp -i &lt;default-private-key&gt; &lt;your-public-key&gt; &lt;user&gt;@&lt;ip&gt;<span class="hljs-symbol">:&lt;destination-path&gt;</span><br></code></pre></td></tr></table></figure><p>舉例：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>scp -i <span class="hljs-keyword">private</span>-key.pem id_rsa.pub user<span class="hljs-variable">@11</span>.<span class="hljs-number">111.123</span>.<span class="hljs-number">123</span>:~<span class="hljs-regexp">/.ssh/id</span>_rsa.pub<br></code></pre></td></tr></table></figure><p>傳送成功後，回到第一個已經連線到伺服器的終端，將傳送成功的公鑰寫入 <code>authorized_keys</code> 檔案中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub &gt;&gt; ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><blockquote><p>注意！請使用 <code>&gt;&gt;</code> (從內容末端接著寫入) 而非 <code>&gt;</code>（全部覆蓋取代）</p></blockquote><h2 id="5-私鑰管理"><a href="#5-私鑰管理" class="headerlink" title="5. 私鑰管理"></a>5. 私鑰管理</h2><p>私鑰的管理上，當私鑰很多時，或是我們時常要進行連線時，要找出對應的私鑰輸入會非常困擾，所以我們可以將私鑰交由 <code>ssh-agent</code> 管理</p><p>首先啟動 <code>ssh-agent</code> 服務</p><p>Mac 環境下執行，執行成功後會顯示 PID 數字</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>eval <span class="hljs-string">`ssh-agent`</span><br></code></pre></td></tr></table></figure><p>使用 <code>ssh-add</code> 指令將私鑰加入</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing">$ ssh-<span class="hljs-built_in">add</span> &lt;your-<span class="hljs-keyword">private</span>-<span class="hljs-built_in">key</span>&gt;<br></code></pre></td></tr></table></figure><p>確認當前被管理私鑰清單</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ ssh-<span class="hljs-built_in">add</span> -l<br></code></pre></td></tr></table></figure><h2 id="6-設定檔"><a href="#6-設定檔" class="headerlink" title="6. 設定檔"></a>6. 設定檔</h2><p>此處只介紹 SSH 客戶端設定檔（<code>/etc/ssh/ssh_config</code>）</p><p>設定檔編寫觀念</p><ul><li>從上到下套用符合 關鍵字的 Host 區塊</li><li>套用過的屬性就不會在套用</li><li>越通用的屬性應該放置越下方</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host apple1<br>    HostName <span class="hljs-number">11.22</span>.<span class="hljs-number">123.123</span><br>    IdentityFile ~/.ssh/id_rsa.aws.apple1<br><br>Host orange1<br>    HostName <span class="hljs-number">11.33</span>.<span class="hljs-number">123.123</span><br>    IdentityFile ~/.ssh/id_rsa.aws.orange1<br><br>Host apple*<br>    <span class="hljs-keyword">User</span> <span class="hljs-title">appleuser</span><br><br>Host orange*<br>    <span class="hljs-keyword">User</span> <span class="hljs-title">orangeuser</span><br><br>Host *<br>    Port <span class="hljs-number">22</span>    <br></code></pre></td></tr></table></figure><blockquote><p>設定檔的鍵值格式也可以是 Port&#x3D;22</p></blockquote><p>當設定檔如上編寫完畢後，我們就可以使用 <code>Host</code> 後方的別名來進行 SSH 連線</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh apple1<br></code></pre></td></tr></table></figure><p>此時，SSH 會套用 <code>Host apple1</code> 和 <code>Host apple*</code> 和 <code>Host *</code> 區塊的設定</p><p>那如果是：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh orange1<br></code></pre></td></tr></table></figure><p>則會套用 <code>Host orange1</code> 和 <code>Host orange*</code> 和 <code>Host *</code> 區塊的設定</p><p>所以設定檔的編寫可以幫助我們，將原本在終端需要輸入的參數省略掉，讓使用上更為方便。</p><h2 id="7-資料來源"><a href="#7-資料來源" class="headerlink" title="7. 資料來源"></a>7. 資料來源</h2><p>整理入門文章、官方文件、和質量高的文章</p><ul><li><a href="https://codecharms.me/posts/security-ssh">SSH 入門文章</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-custom-connection-options-for-your-ssh-client">SSH 設定檔配置觀念</a></li><li><a href="https://www.openssh.com/">OpenSSH 文件</a></li><li><a href="https://www.ssh.com/academy/ssh/config">SSH 文件</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ssh, linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MariaDB 終端操作（Command-Line Client）</title>
    <link href="/2022/03/21/MariaDB-%E7%B5%82%E7%AB%AF%E6%93%8D%E4%BD%9C%EF%BC%88Command-Line-Client%EF%BC%89/"/>
    <url>/2022/03/21/MariaDB-%E7%B5%82%E7%AB%AF%E6%93%8D%E4%BD%9C%EF%BC%88Command-Line-Client%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-學習終端介面操作資料庫的理由？"><a href="#1-學習終端介面操作資料庫的理由？" class="headerlink" title="1. 學習終端介面操作資料庫的理由？"></a>1. 學習終端介面操作資料庫的理由？</h2><p>在 <a href="https://www.apachefriends.org/index.html">XAMPP</a> 提供的 PHP 開發環境中，我們可以輕易的搭載出 MariaDB 伺服器，同時還可以透過 PHPMyAdmin 提供的圖形化介面對資料庫進行操作。 </p><blockquote><p>XAMPP (Apache + MariaDB + PHP + Perl)：PHP 開發環境的組合包</p></blockquote><p>當試著自己實作將網站搬到 AWS 所提供的 EC2 服務時，就面臨著要如何在全終端的介面下將資料庫伺服器運行起來？</p><p>下方文章整理自己剛從 XAMPP 環境搬移資料庫到 Linux (CentOS 7) 上需要知道的幾件事。</p><p>文末附上資料庫終端操作介面的作弊表，提供快速查詢。</p><blockquote><p>對於網站上架，有許多解決方案（LAMP…等），這裡只紀錄自己選擇的解決方式。</p></blockquote><h2 id="2-前置知識"><a href="#2-前置知識" class="headerlink" title="2. 前置知識"></a>2. 前置知識</h2><h3 id="2-1-mysql-和-mariadb-這兩個指令一樣嗎？"><a href="#2-1-mysql-和-mariadb-這兩個指令一樣嗎？" class="headerlink" title="2.1 mysql 和 mariadb 這兩個指令一樣嗎？"></a>2.1 <code>mysql</code> 和 <code>mariadb</code> 這兩個指令一樣嗎？</h3><p>剛開始查詢相關資料時，許多教學文都說在終端鍵入 <code>mysql</code> 就可以進入資料庫操作介面，但我們用的明明就是 mariadb 為什麼是打 <code>mysql</code>，試著在 Mac 終端環境下打 <code>mariadb</code> 發現也可以進入，似乎有同樣的效果？</p><p>讓我們看下官方文件給出的解釋。</p><blockquote><p><strong>MariaDB starting with 10.4.6</strong><br>From MariaDB 10.4.6, <em><code>mariadb</code> is a symlink to <code>mysql</code>, the command-line client</em>.<br>See mysql Command-Line Client for details.</p><p><strong>MariaDB starting with 10.5.2</strong><br>From MariaDB 10.5.2, <em><code>mariadb</code> is the name of the command-line client, with <code>mysql</code> a symlink</em>.</p></blockquote><p>這邊自己的理解是，<code>mysql</code> 和 <code>mariadb</code> 兩個指令是通用的？只是歷史因素，所以一般仍習慣使用 <code>mysql</code> 指令。</p><h3 id="2-2-mysql-和-mysqld-這兩個指令差在哪？多了一個-d-是什麼意思？"><a href="#2-2-mysql-和-mysqld-這兩個指令差在哪？多了一個-d-是什麼意思？" class="headerlink" title="2.2 mysql 和 mysqld 這兩個指令差在哪？多了一個 d 是什麼意思？"></a>2.2 <code>mysql</code> 和 <code>mysqld</code> 這兩個指令差在哪？多了一個 d 是什麼意思？</h3><p><code>mysql</code> 是進入資料庫終端操作介面，而 <code>mysqld</code> 則是將資料庫伺服器啟動起來，換句話說在使用 <code>mysql</code> 指令前，需要確保已經使用過 <code>mysqld</code> 將資料庫服務運行起來（Linux 中使用 <code>systemctl start mariadb.service</code> 將服務運行起來）。</p><p>在尋找資料的過程中，發現末端帶 d 這件事似乎是一個慣例，而 d 的意思是 daemon，意思是這個程序是 daemon process，目前的理解是：</p><ul><li>daemon process: 守護程序，除非系統關閉或是主動砍掉進程，否則該程序一直運行。</li><li>normal process: 一般程序，當父進程關閉（例如：終端關閉），則程序也跟著關閉。</li></ul><h2 id="3-實際操作"><a href="#3-實際操作" class="headerlink" title="3. 實際操作"></a>3. 實際操作</h2><h3 id="3-1-安裝資料庫服務"><a href="#3-1-安裝資料庫服務" class="headerlink" title="3.1 安裝資料庫服務"></a>3.1 安裝資料庫服務</h3><ul><li>Linux (CentOS 7): 使用 yum 指令安裝 mariadb<br><code>yum install mariadb</code></li><li>Mac: 使用 brew 指令安裝 mariadb<br><code>brew install mariadb</code></li></ul><h3 id="3-2-啟動資料庫服務"><a href="#3-2-啟動資料庫服務" class="headerlink" title="3.2 啟動資料庫服務"></a>3.2 啟動資料庫服務</h3><ul><li>Linux (CentOS 7): 使用 systemctl 指令啟動 mariadb<br><code>systemctl start mariadb.service</code></li><li>Mac: 使用 mysqld<br><code>mysqld</code> or <code>mariadbd</code><blockquote><p><a href="https://mariadb.com/kb/en/starting-and-stopping-mariadb-automatically/">https://mariadb.com/kb/en/starting-and-stopping-mariadb-automatically/</a></p></blockquote></li></ul><h3 id="3-3-關閉資料庫服務"><a href="#3-3-關閉資料庫服務" class="headerlink" title="3.3 關閉資料庫服務"></a>3.3 關閉資料庫服務</h3><ul><li>Linux (CentOS 7):<br><code>systemctl stop mariadb.service</code><blockquote><p><a href="https://mariadb.com/kb/en/systemd/">https://mariadb.com/kb/en/systemd/</a></p></blockquote></li><li>Mac:<br><code>mysqladmin --wait-for-all-slaves shutdown</code><blockquote><p><a href="https://mariadb.com/kb/en/mysqladmin/">https://mariadb.com/kb/en/mysqladmin/</a></p></blockquote></li></ul><blockquote><p>注意：直接使用 <code>kill -9 &lt;PID&gt;</code> 關閉資料庫，會壞掉（詳細原因不清楚）</p></blockquote><h3 id="3-4-進入資料庫操作環境"><a href="#3-4-進入資料庫操作環境" class="headerlink" title="3.4 進入資料庫操作環境"></a>3.4 進入資料庫操作環境</h3><p>進入資料庫終端操作介面後，在 Linux (CentOS 7) 和 Mac 環境下，基本上操作方式都一致（目前沒有遇到不相同）<br><code>mysql</code><br>or<br><code>mysql --user=&lt;your-user-name&gt; --password=&lt;your-password&gt; [database-name]</code></p><h3 id="3-5-基本觀念"><a href="#3-5-基本觀念" class="headerlink" title="3.5 基本觀念"></a>3.5 基本觀念</h3><ul><li>在資料庫專端介面中所有語句結尾都需要加上 <code>;</code> or <code>\g</code> or <code>\G</code> (大寫 G 可以使返回結果垂直排列)</li><li>如何查找指令使用方式？問號後給出關鍵字即可 <code>? &lt;keyword&gt;</code></li><li><code>help</code> or <code>\h</code> 指令，列出命令清單</li></ul><h3 id="3-6-一般操作"><a href="#3-6-一般操作" class="headerlink" title="3.6 一般操作"></a>3.6 一般操作</h3><ul><li>查看當前資料庫<br><code>SHOW databases;</code></li><li>切換資料庫<br><code>USE &lt;your-database&gt;;</code></li><li>查看資料表（記得要先切到特定資料庫）<br><code>SHOW tables;</code></li><li>查看資料欄位（記得要先切到特定資料庫）<br><code>DESC &lt;your-table&gt;;</code></li><li>查看當前資料庫版本<br><code>SELECT version();</code></li><li>查看當前使用者<br><code>SELECT user();</code></li><li>查看使用者列表（使用者資料會被存在名為 mysql 庫的 user 表中）<br><code>SELECT user, host FROM mysql.user</code></li><li>建立使用者<br><code>CREATE USER &#39;jeffrey&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mypass&#39;;</code></li><li>設定使用者權限（ALL 表示權限全開，ON 後面接特定資料庫表，TO 接使用者）<br><code>GRANT ALL ON db1.* TO &#39;jeffrey&#39;@&#39;localhost&#39;;</code><br>or<br><code>GRANT ALL PRIVILEGES ON &#39;your-db-name&#39;.* to &#39;your-user-name&#39;@&#39;%&#39; WITH GRANT OPTION;</code></li><li>匯入資料庫<br><code>source &lt;your_.sql_file_path&gt;</code></li><li>重置 AUTO_INCREMENT<br><code>ALTER TABLE &#39;your-table-name&#39; AUTO_INCREMENT = 1</code></li></ul><h2 id="4-其餘進階操作"><a href="#4-其餘進階操作" class="headerlink" title="4. 其餘進階操作"></a>4. 其餘進階操作</h2><ul><li>資料庫操作</li><li>資料表操作<ul><li>修改資料表名稱<br>  <code>ALTER TABLE &lt;old_name&gt; RENAME TO &lt;new_name&gt;;</code></li></ul></li><li>欄位操作<ul><li>顯示欄位資訊<br>  <code>DESC &lt;table&gt;;</code><br>  or<br>  <code>SELECT COLUMNS FROM &lt;table&gt;;</code></li></ul></li><li><a href="https://mariadb.com/kb/en/account-management-sql-commands/">使用者管理</a><ul><li>建立使用者<br>  <code>CREATE USER &lt;someone@localhost&gt; IDENTIFIED BY &lt;password&gt;;</code></li><li>移除使用者<br>  <code>DROP USER &lt;someone@localhost&gt;;</code></li><li>查看使用者和連線資訊<br>  <code>SELECT user, host FROM mysql.user</code><blockquote><p>使用者的 host，表示限制該使用者必須來自該網段才允許連線（user@localhost -&gt; 該使用者必須來自本機）</p></blockquote></li><li>資料庫的 15 種權限<br>  ALL PRIVILEGES | ALTER | CREATE | DELETE | DROP | FILE | INDEX | INSERT | PROCESS | REFERENCES | RELOAD | SELECT | SHUTDOWN | UPDATE | USAGE</li><li>資料表的 8 種權限<br>  SELECT | INSERT | UPDATE | DELETE | CREATE | DROP | INDEX | ALRTER</li><li>資料欄位的 3 種權限<br>  SELECT | INSERT | UPDATE</li><li>查看使用者權限<br>  <code>SHOW GRANTS FOR &lt;someone@localhost&gt;;</code> : 顯示使用者 &lt;someone@localhost&gt; 權限<br>  or<br>  <code>SHOW GRANTS;</code> : 顯示當前使用者權限</li></ul></li><li>資料庫匯出</li><li>修復與優化<br>  <code>REPAIR TABLE &lt;table&gt;;</code><br>  <code>OPTIMIZE TABLE &lt;table&gt;;</code></li><li>其他<br>  <code>mysqladmin ping;</code><br>  <code>mysqladmin variables;</code><br>  <code>mysqladmin reload;</code></li></ul><h2 id="5-文章查詢"><a href="#5-文章查詢" class="headerlink" title="5. 文章查詢"></a>5. 文章查詢</h2><ul><li><a href="https://mariadb.com/kb/en/documentation/">https://mariadb.com/kb/en/documentation/</a></li><li><a href="https://www.mysqltutorial.org/">https://www.mysqltutorial.org</a></li><li><a href="https://blog.xuite.net/towns/hc/65849335">https://blog.xuite.net/towns/hc/65849335</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mysql, mariadb, linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
